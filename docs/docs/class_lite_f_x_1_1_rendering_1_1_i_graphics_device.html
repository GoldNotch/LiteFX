<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LiteFX: LiteFX::Rendering::IGraphicsDevice&lt; TFactory, TSurface, TGraphicsAdapter, TSwapChain, TCommandQueue, TRenderPass, TFrameBuffer, TRenderPipeline, TInputAttachmentMapping, TCommandBuffer, TImage, TVertexBuffer, TIndexBuffer, TDescriptorLayout, TBuffer, TSampler &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo_xs.png"/></td>
  <td id="projectalign">
   <div id="projectname">LiteFX<span id="projectnumber">&#160;0.2.2.2022</span>
   </div>
   <div id="projectbrief">Computer Graphics Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">LiteFX::Rendering::IGraphicsDevice&lt; TFactory, TSurface, TGraphicsAdapter, TSwapChain, TCommandQueue, TRenderPass, TFrameBuffer, TRenderPipeline, TInputAttachmentMapping, TCommandBuffer, TImage, TVertexBuffer, TIndexBuffer, TDescriptorLayout, TBuffer, TSampler &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Represents the graphics device that a rendering back-end is doing work on.  
 <a href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="rendering_8hpp_source.html">rendering.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a288de2c6866a8454fca7288e956c11e5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#a288de2c6866a8454fca7288e956c11e5">surface_type</a> = TSurface</td></tr>
<tr class="separator:a288de2c6866a8454fca7288e956c11e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb3af62cc8abfa65bd47ce2d84426dc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#a3eb3af62cc8abfa65bd47ce2d84426dc">adapter_type</a> = TGraphicsAdapter</td></tr>
<tr class="separator:a3eb3af62cc8abfa65bd47ce2d84426dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a82c8adc3ec9c4be8f04eb193e8e18"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#a90a82c8adc3ec9c4be8f04eb193e8e18">swap_chain_type</a> = TSwapChain</td></tr>
<tr class="separator:a90a82c8adc3ec9c4be8f04eb193e8e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5efb713c0ca150b96e2bfce34947182"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#ae5efb713c0ca150b96e2bfce34947182">command_queue_type</a> = TCommandQueue</td></tr>
<tr class="separator:ae5efb713c0ca150b96e2bfce34947182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f392e68754bda10a6ca624bcdc6a582"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#a1f392e68754bda10a6ca624bcdc6a582">factory_type</a> = TFactory</td></tr>
<tr class="separator:a1f392e68754bda10a6ca624bcdc6a582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b90ca546805019998f7b66e3e26cd4a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#a8b90ca546805019998f7b66e3e26cd4a">frame_buffer_type</a> = TFrameBuffer</td></tr>
<tr class="separator:a8b90ca546805019998f7b66e3e26cd4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad99053aebdf926a39b013ccc1d7d8501"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#ad99053aebdf926a39b013ccc1d7d8501">render_pass_type</a> = TRenderPass</td></tr>
<tr class="separator:ad99053aebdf926a39b013ccc1d7d8501"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a59698c19d501cb3cd3638d83472fa23b"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#a59698c19d501cb3cd3638d83472fa23b">~IGraphicsDevice</a> () noexcept=default</td></tr>
<tr class="separator:a59698c19d501cb3cd3638d83472fa23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a6413f74e5070d12ade6db1fd80fcc"><td class="memItemLeft" align="right" valign="top">virtual const TSurface &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#a09a6413f74e5070d12ade6db1fd80fcc">surface</a> () const noexcept=0</td></tr>
<tr class="memdesc:a09a6413f74e5070d12ade6db1fd80fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the surface, the device draws to.  <a href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#a09a6413f74e5070d12ade6db1fd80fcc">More...</a><br /></td></tr>
<tr class="separator:a09a6413f74e5070d12ade6db1fd80fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade862c74efb50389c14de53a7f24b7a2"><td class="memItemLeft" align="right" valign="top">virtual const TGraphicsAdapter &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#ade862c74efb50389c14de53a7f24b7a2">adapter</a> () const noexcept=0</td></tr>
<tr class="memdesc:ade862c74efb50389c14de53a7f24b7a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the graphics adapter, the device uses for drawing.  <a href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#ade862c74efb50389c14de53a7f24b7a2">More...</a><br /></td></tr>
<tr class="separator:ade862c74efb50389c14de53a7f24b7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07714bbea25139269950bd56daa015a"><td class="memItemLeft" align="right" valign="top">virtual const TSwapChain &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#af07714bbea25139269950bd56daa015a">swapChain</a> () const noexcept=0</td></tr>
<tr class="memdesc:af07714bbea25139269950bd56daa015a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the swap chain, that contains the back and front buffers used for presentation.  <a href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#af07714bbea25139269950bd56daa015a">More...</a><br /></td></tr>
<tr class="separator:af07714bbea25139269950bd56daa015a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430dfbe808b706d594590f0ccddb4fba"><td class="memItemLeft" align="right" valign="top">virtual const TFactory &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#a430dfbe808b706d594590f0ccddb4fba">factory</a> () const noexcept=0</td></tr>
<tr class="memdesc:a430dfbe808b706d594590f0ccddb4fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the factory instance, used to create instances from the device.  <a href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#a430dfbe808b706d594590f0ccddb4fba">More...</a><br /></td></tr>
<tr class="separator:a430dfbe808b706d594590f0ccddb4fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7277b5f6e15ce232246f701d17a97b"><td class="memItemLeft" align="right" valign="top">virtual const TCommandQueue &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#aca7277b5f6e15ce232246f701d17a97b">graphicsQueue</a> () const noexcept=0</td></tr>
<tr class="memdesc:aca7277b5f6e15ce232246f701d17a97b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the instance of the queue, used to process draw calls.  <a href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#aca7277b5f6e15ce232246f701d17a97b">More...</a><br /></td></tr>
<tr class="separator:aca7277b5f6e15ce232246f701d17a97b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132a6c39e93fd7d0f692b7982b1c8abf"><td class="memItemLeft" align="right" valign="top">virtual const TCommandQueue &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#a132a6c39e93fd7d0f692b7982b1c8abf">transferQueue</a> () const noexcept=0</td></tr>
<tr class="memdesc:a132a6c39e93fd7d0f692b7982b1c8abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the instance of the queue used for device-device transfers (e.g. between render-passes).  <a href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#a132a6c39e93fd7d0f692b7982b1c8abf">More...</a><br /></td></tr>
<tr class="separator:a132a6c39e93fd7d0f692b7982b1c8abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e390c25a4ca7e70a58e8c14ffc0e37e"><td class="memItemLeft" align="right" valign="top">virtual const TCommandQueue &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#a7e390c25a4ca7e70a58e8c14ffc0e37e">bufferQueue</a> () const noexcept=0</td></tr>
<tr class="memdesc:a7e390c25a4ca7e70a58e8c14ffc0e37e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the instance of the queue used for host-device transfers.  <a href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#a7e390c25a4ca7e70a58e8c14ffc0e37e">More...</a><br /></td></tr>
<tr class="separator:a7e390c25a4ca7e70a58e8c14ffc0e37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b64e41cd0022794bb47bb49712bee80"><td class="memItemLeft" align="right" valign="top">virtual const TCommandQueue &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#a4b64e41cd0022794bb47bb49712bee80">computeQueue</a> () const noexcept=0</td></tr>
<tr class="memdesc:a4b64e41cd0022794bb47bb49712bee80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the instance of the queue used for compute calls.  <a href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#a4b64e41cd0022794bb47bb49712bee80">More...</a><br /></td></tr>
<tr class="separator:a4b64e41cd0022794bb47bb49712bee80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29cfb8f4df1969b816781a2a1ccf9675"><td class="memItemLeft" align="right" valign="top">virtual MultiSamplingLevel&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#a29cfb8f4df1969b816781a2a1ccf9675">maximumMultiSamplingLevel</a> (const Format &amp;format) const noexcept=0</td></tr>
<tr class="memdesc:a29cfb8f4df1969b816781a2a1ccf9675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries the device for the maximum supported number of multi-sampling levels.  <a href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#a29cfb8f4df1969b816781a2a1ccf9675">More...</a><br /></td></tr>
<tr class="separator:a29cfb8f4df1969b816781a2a1ccf9675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc74be39636c093c3db1d45e3d0e28d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#a1cc74be39636c093c3db1d45e3d0e28d">wait</a> () const =0</td></tr>
<tr class="memdesc:a1cc74be39636c093c3db1d45e3d0e28d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until the device is idle.  <a href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#a1cc74be39636c093c3db1d45e3d0e28d">More...</a><br /></td></tr>
<tr class="separator:a1cc74be39636c093c3db1d45e3d0e28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename TFactory, typename TSurface, typename TGraphicsAdapter, typename TSwapChain, typename TCommandQueue, typename TRenderPass, typename TFrameBuffer = TRenderPass::frame_buffer_type, typename TRenderPipeline = TRenderPass::render_pipeline_type, typename TInputAttachmentMapping = TRenderPass::input_attachment_mapping_type, typename TCommandBuffer = TCommandQueue::command_buffer_type, typename TImage = TFactory::image_type, typename TVertexBuffer = TFactory::vertex_buffer_type, typename TIndexBuffer = TFactory::index_buffer_type, typename TDescriptorLayout = TFactory::descriptor_layout_type, typename TBuffer = TFactory::buffer_type, typename TSampler = TFactory::sampler_type&gt;<br />
requires rtti::implements&lt;TSurface, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_surface.html">ISurface</a>&gt; &amp;&amp; rtti::implements&lt;TGraphicsAdapter, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_adapter.html">IGraphicsAdapter</a>&gt; &amp;&amp; rtti::implements&lt;TSwapChain, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_swap_chain.html">ISwapChain</a>&lt;TImage&gt;&gt; &amp;&amp; rtti::implements&lt;TCommandQueue, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html">ICommandQueue</a>&lt;TCommandBuffer&gt;&gt; &amp;&amp; rtti::implements&lt;TFactory, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_factory.html">IGraphicsFactory</a>&lt;TDescriptorLayout, TBuffer, TVertexBuffer, TIndexBuffer, TImage, TSampler&gt;&gt; &amp;&amp; rtti::implements&lt;TRenderPass, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_render_pass.html">IRenderPass</a>&lt;TRenderPipeline, TFrameBuffer, TInputAttachmentMapping&gt;&gt;<br />
class LiteFX::Rendering::IGraphicsDevice&lt; TFactory, TSurface, TGraphicsAdapter, TSwapChain, TCommandQueue, TRenderPass, TFrameBuffer, TRenderPipeline, TInputAttachmentMapping, TCommandBuffer, TImage, TVertexBuffer, TIndexBuffer, TDescriptorLayout, TBuffer, TSampler &gt;</div><p >Represents the graphics device that a rendering back-end is doing work on. </p>
<p >The graphics device is the central instance of a renderer. It has two major roles. First, it maintains the <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_factory.html" title="Describes a factory that creates objects for a IGraphicsDevice.">IGraphicsFactory</a> instance, that is used to facilitate common objects. Second, it owns the device state, which contains objects required for communication between your application and the graphics driver. Most notably, those objects contain the <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_swap_chain.html" title="Represents a swap chain, i.e. a chain of multiple IImage instances, that can be presented to a ISurfa...">ISwapChain</a> instance and the <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html" title="Represents a command queue.">ICommandQueue</a> instances used for data and command transfer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFactory</td><td>The type of the graphics factory. Must implement <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_factory.html" title="Describes a factory that creates objects for a IGraphicsDevice.">IGraphicsFactory</a>.</td></tr>
    <tr><td class="paramname">TSurface</td><td>The type of the surface. Must implement <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_surface.html" title="Represents a surface to render to.">ISurface</a>.</td></tr>
    <tr><td class="paramname">TGraphicsAdapter</td><td>The type of the graphics adapter. Must implement <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_adapter.html" title="Represents a physical graphics adapter.">IGraphicsAdapter</a>.</td></tr>
    <tr><td class="paramname">TSwapChain</td><td>The type of the swap chain. Must implement <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_swap_chain.html" title="Represents a swap chain, i.e. a chain of multiple IImage instances, that can be presented to a ISurfa...">ISwapChain</a>.</td></tr>
    <tr><td class="paramname">TCommandQueue</td><td>The type of the command queue. Must implement <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html" title="Represents a command queue.">ICommandQueue</a>.</td></tr>
    <tr><td class="paramname">TRenderPass</td><td>The type of the render pass. Must implement <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_render_pass.html" title="Represents a render pass.">IRenderPass</a>.</td></tr>
    <tr><td class="paramname">TRenderPipeline</td><td>The type of the render pipeline. Must implement <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_render_pipeline.html" title="Represents a graphics IPipeline.">IRenderPipeline</a>.</td></tr>
    <tr><td class="paramname">TImage</td><td>The type of the swap chain image. Must inherit from <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_image.html" title="Describes a generic image.">IImage</a>.</td></tr>
    <tr><td class="paramname">TFrameBuffer</td><td>The type of the frame buffer. Must implement <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_frame_buffer.html" title="Stores the images for the output attachments for a back buffer of a IRenderPass, as well as a IComman...">IFrameBuffer</a>.</td></tr>
    <tr><td class="paramname">TInputAttachmentMapping</td><td>The type of the input attachment mapping. Must implement <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_input_attachment_mapping.html" title="Represents a mapping between a set of IRenderTarget instances and the input attachments of a IRenderP...">IInputAttachmentMapping</a>.</td></tr>
    <tr><td class="paramname">TCommandBuffer</td><td>The type of the command buffer. Must implement <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html" title="Represents a command buffer, that buffers commands that should be submitted to a ICommandQueue.">ICommandBuffer</a>.</td></tr>
    <tr><td class="paramname">TVertexBufferLayout</td><td>The type of the vertex buffer layout. Must implement <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_vertex_buffer_layout.html" title="Describes a vertex buffer layout.">IVertexBufferLayout</a>.</td></tr>
    <tr><td class="paramname">TIndexBufferLayout</td><td>The type of the index buffer layout. Must implement <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_index_buffer_layout.html" title="Describes a index buffer layout.">IIndexBufferLayout</a>.</td></tr>
    <tr><td class="paramname">TDescriptorLayout</td><td>The type of the descriptor layout. Must implement <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_descriptor_layout.html" title="Describes a the layout of a single descriptor within a IDescriptorSet.">IDescriptorLayout</a>.</td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a3eb3af62cc8abfa65bd47ce2d84426dc" name="a3eb3af62cc8abfa65bd47ce2d84426dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb3af62cc8abfa65bd47ce2d84426dc">&#9670;&nbsp;</a></span>adapter_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFactory , typename TSurface , typename TGraphicsAdapter , typename TSwapChain , typename TCommandQueue , typename TRenderPass , typename TFrameBuffer  = TRenderPass::frame_buffer_type, typename TRenderPipeline  = TRenderPass::render_pipeline_type, typename TInputAttachmentMapping  = TRenderPass::input_attachment_mapping_type, typename TCommandBuffer  = TCommandQueue::command_buffer_type, typename TImage  = TFactory::image_type, typename TVertexBuffer  = TFactory::vertex_buffer_type, typename TIndexBuffer  = TFactory::index_buffer_type, typename TDescriptorLayout  = TFactory::descriptor_layout_type, typename TBuffer  = TFactory::buffer_type, typename TSampler  = TFactory::sampler_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html">LiteFX::Rendering::IGraphicsDevice</a>&lt; TFactory, TSurface, TGraphicsAdapter, TSwapChain, TCommandQueue, TRenderPass, TFrameBuffer, TRenderPipeline, TInputAttachmentMapping, TCommandBuffer, TImage, TVertexBuffer, TIndexBuffer, TDescriptorLayout, TBuffer, TSampler &gt;::adapter_type =  TGraphicsAdapter</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5efb713c0ca150b96e2bfce34947182" name="ae5efb713c0ca150b96e2bfce34947182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5efb713c0ca150b96e2bfce34947182">&#9670;&nbsp;</a></span>command_queue_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFactory , typename TSurface , typename TGraphicsAdapter , typename TSwapChain , typename TCommandQueue , typename TRenderPass , typename TFrameBuffer  = TRenderPass::frame_buffer_type, typename TRenderPipeline  = TRenderPass::render_pipeline_type, typename TInputAttachmentMapping  = TRenderPass::input_attachment_mapping_type, typename TCommandBuffer  = TCommandQueue::command_buffer_type, typename TImage  = TFactory::image_type, typename TVertexBuffer  = TFactory::vertex_buffer_type, typename TIndexBuffer  = TFactory::index_buffer_type, typename TDescriptorLayout  = TFactory::descriptor_layout_type, typename TBuffer  = TFactory::buffer_type, typename TSampler  = TFactory::sampler_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html">LiteFX::Rendering::IGraphicsDevice</a>&lt; TFactory, TSurface, TGraphicsAdapter, TSwapChain, TCommandQueue, TRenderPass, TFrameBuffer, TRenderPipeline, TInputAttachmentMapping, TCommandBuffer, TImage, TVertexBuffer, TIndexBuffer, TDescriptorLayout, TBuffer, TSampler &gt;::command_queue_type =  TCommandQueue</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f392e68754bda10a6ca624bcdc6a582" name="a1f392e68754bda10a6ca624bcdc6a582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f392e68754bda10a6ca624bcdc6a582">&#9670;&nbsp;</a></span>factory_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFactory , typename TSurface , typename TGraphicsAdapter , typename TSwapChain , typename TCommandQueue , typename TRenderPass , typename TFrameBuffer  = TRenderPass::frame_buffer_type, typename TRenderPipeline  = TRenderPass::render_pipeline_type, typename TInputAttachmentMapping  = TRenderPass::input_attachment_mapping_type, typename TCommandBuffer  = TCommandQueue::command_buffer_type, typename TImage  = TFactory::image_type, typename TVertexBuffer  = TFactory::vertex_buffer_type, typename TIndexBuffer  = TFactory::index_buffer_type, typename TDescriptorLayout  = TFactory::descriptor_layout_type, typename TBuffer  = TFactory::buffer_type, typename TSampler  = TFactory::sampler_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html">LiteFX::Rendering::IGraphicsDevice</a>&lt; TFactory, TSurface, TGraphicsAdapter, TSwapChain, TCommandQueue, TRenderPass, TFrameBuffer, TRenderPipeline, TInputAttachmentMapping, TCommandBuffer, TImage, TVertexBuffer, TIndexBuffer, TDescriptorLayout, TBuffer, TSampler &gt;::factory_type =  TFactory</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b90ca546805019998f7b66e3e26cd4a" name="a8b90ca546805019998f7b66e3e26cd4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b90ca546805019998f7b66e3e26cd4a">&#9670;&nbsp;</a></span>frame_buffer_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFactory , typename TSurface , typename TGraphicsAdapter , typename TSwapChain , typename TCommandQueue , typename TRenderPass , typename TFrameBuffer  = TRenderPass::frame_buffer_type, typename TRenderPipeline  = TRenderPass::render_pipeline_type, typename TInputAttachmentMapping  = TRenderPass::input_attachment_mapping_type, typename TCommandBuffer  = TCommandQueue::command_buffer_type, typename TImage  = TFactory::image_type, typename TVertexBuffer  = TFactory::vertex_buffer_type, typename TIndexBuffer  = TFactory::index_buffer_type, typename TDescriptorLayout  = TFactory::descriptor_layout_type, typename TBuffer  = TFactory::buffer_type, typename TSampler  = TFactory::sampler_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html">LiteFX::Rendering::IGraphicsDevice</a>&lt; TFactory, TSurface, TGraphicsAdapter, TSwapChain, TCommandQueue, TRenderPass, TFrameBuffer, TRenderPipeline, TInputAttachmentMapping, TCommandBuffer, TImage, TVertexBuffer, TIndexBuffer, TDescriptorLayout, TBuffer, TSampler &gt;::frame_buffer_type =  TFrameBuffer</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad99053aebdf926a39b013ccc1d7d8501" name="ad99053aebdf926a39b013ccc1d7d8501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad99053aebdf926a39b013ccc1d7d8501">&#9670;&nbsp;</a></span>render_pass_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFactory , typename TSurface , typename TGraphicsAdapter , typename TSwapChain , typename TCommandQueue , typename TRenderPass , typename TFrameBuffer  = TRenderPass::frame_buffer_type, typename TRenderPipeline  = TRenderPass::render_pipeline_type, typename TInputAttachmentMapping  = TRenderPass::input_attachment_mapping_type, typename TCommandBuffer  = TCommandQueue::command_buffer_type, typename TImage  = TFactory::image_type, typename TVertexBuffer  = TFactory::vertex_buffer_type, typename TIndexBuffer  = TFactory::index_buffer_type, typename TDescriptorLayout  = TFactory::descriptor_layout_type, typename TBuffer  = TFactory::buffer_type, typename TSampler  = TFactory::sampler_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html">LiteFX::Rendering::IGraphicsDevice</a>&lt; TFactory, TSurface, TGraphicsAdapter, TSwapChain, TCommandQueue, TRenderPass, TFrameBuffer, TRenderPipeline, TInputAttachmentMapping, TCommandBuffer, TImage, TVertexBuffer, TIndexBuffer, TDescriptorLayout, TBuffer, TSampler &gt;::render_pass_type =  TRenderPass</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a288de2c6866a8454fca7288e956c11e5" name="a288de2c6866a8454fca7288e956c11e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a288de2c6866a8454fca7288e956c11e5">&#9670;&nbsp;</a></span>surface_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFactory , typename TSurface , typename TGraphicsAdapter , typename TSwapChain , typename TCommandQueue , typename TRenderPass , typename TFrameBuffer  = TRenderPass::frame_buffer_type, typename TRenderPipeline  = TRenderPass::render_pipeline_type, typename TInputAttachmentMapping  = TRenderPass::input_attachment_mapping_type, typename TCommandBuffer  = TCommandQueue::command_buffer_type, typename TImage  = TFactory::image_type, typename TVertexBuffer  = TFactory::vertex_buffer_type, typename TIndexBuffer  = TFactory::index_buffer_type, typename TDescriptorLayout  = TFactory::descriptor_layout_type, typename TBuffer  = TFactory::buffer_type, typename TSampler  = TFactory::sampler_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html">LiteFX::Rendering::IGraphicsDevice</a>&lt; TFactory, TSurface, TGraphicsAdapter, TSwapChain, TCommandQueue, TRenderPass, TFrameBuffer, TRenderPipeline, TInputAttachmentMapping, TCommandBuffer, TImage, TVertexBuffer, TIndexBuffer, TDescriptorLayout, TBuffer, TSampler &gt;::surface_type =  TSurface</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a90a82c8adc3ec9c4be8f04eb193e8e18" name="a90a82c8adc3ec9c4be8f04eb193e8e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90a82c8adc3ec9c4be8f04eb193e8e18">&#9670;&nbsp;</a></span>swap_chain_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFactory , typename TSurface , typename TGraphicsAdapter , typename TSwapChain , typename TCommandQueue , typename TRenderPass , typename TFrameBuffer  = TRenderPass::frame_buffer_type, typename TRenderPipeline  = TRenderPass::render_pipeline_type, typename TInputAttachmentMapping  = TRenderPass::input_attachment_mapping_type, typename TCommandBuffer  = TCommandQueue::command_buffer_type, typename TImage  = TFactory::image_type, typename TVertexBuffer  = TFactory::vertex_buffer_type, typename TIndexBuffer  = TFactory::index_buffer_type, typename TDescriptorLayout  = TFactory::descriptor_layout_type, typename TBuffer  = TFactory::buffer_type, typename TSampler  = TFactory::sampler_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html">LiteFX::Rendering::IGraphicsDevice</a>&lt; TFactory, TSurface, TGraphicsAdapter, TSwapChain, TCommandQueue, TRenderPass, TFrameBuffer, TRenderPipeline, TInputAttachmentMapping, TCommandBuffer, TImage, TVertexBuffer, TIndexBuffer, TDescriptorLayout, TBuffer, TSampler &gt;::swap_chain_type =  TSwapChain</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a59698c19d501cb3cd3638d83472fa23b" name="a59698c19d501cb3cd3638d83472fa23b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59698c19d501cb3cd3638d83472fa23b">&#9670;&nbsp;</a></span>~IGraphicsDevice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFactory , typename TSurface , typename TGraphicsAdapter , typename TSwapChain , typename TCommandQueue , typename TRenderPass , typename TFrameBuffer  = TRenderPass::frame_buffer_type, typename TRenderPipeline  = TRenderPass::render_pipeline_type, typename TInputAttachmentMapping  = TRenderPass::input_attachment_mapping_type, typename TCommandBuffer  = TCommandQueue::command_buffer_type, typename TImage  = TFactory::image_type, typename TVertexBuffer  = TFactory::vertex_buffer_type, typename TIndexBuffer  = TFactory::index_buffer_type, typename TDescriptorLayout  = TFactory::descriptor_layout_type, typename TBuffer  = TFactory::buffer_type, typename TSampler  = TFactory::sampler_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html">LiteFX::Rendering::IGraphicsDevice</a>&lt; TFactory, TSurface, TGraphicsAdapter, TSwapChain, TCommandQueue, TRenderPass, TFrameBuffer, TRenderPipeline, TInputAttachmentMapping, TCommandBuffer, TImage, TVertexBuffer, TIndexBuffer, TDescriptorLayout, TBuffer, TSampler &gt;::~<a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html">IGraphicsDevice</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ade862c74efb50389c14de53a7f24b7a2" name="ade862c74efb50389c14de53a7f24b7a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade862c74efb50389c14de53a7f24b7a2">&#9670;&nbsp;</a></span>adapter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFactory , typename TSurface , typename TGraphicsAdapter , typename TSwapChain , typename TCommandQueue , typename TRenderPass , typename TFrameBuffer  = TRenderPass::frame_buffer_type, typename TRenderPipeline  = TRenderPass::render_pipeline_type, typename TInputAttachmentMapping  = TRenderPass::input_attachment_mapping_type, typename TCommandBuffer  = TCommandQueue::command_buffer_type, typename TImage  = TFactory::image_type, typename TVertexBuffer  = TFactory::vertex_buffer_type, typename TIndexBuffer  = TFactory::index_buffer_type, typename TDescriptorLayout  = TFactory::descriptor_layout_type, typename TBuffer  = TFactory::buffer_type, typename TSampler  = TFactory::sampler_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const TGraphicsAdapter &amp; <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html">LiteFX::Rendering::IGraphicsDevice</a>&lt; TFactory, TSurface, TGraphicsAdapter, TSwapChain, TCommandQueue, TRenderPass, TFrameBuffer, TRenderPipeline, TInputAttachmentMapping, TCommandBuffer, TImage, TVertexBuffer, TIndexBuffer, TDescriptorLayout, TBuffer, TSampler &gt;::adapter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the graphics adapter, the device uses for drawing. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference of the graphics adapter, the device uses for drawing.</dd></dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_device.html#adef9a98591d08e41c45e513ca62b6fdc">LiteFX::Rendering::Backends::DirectX12Device</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_device.html#a5cb0342b96b76c100809173b80e2514c">LiteFX::Rendering::Backends::VulkanDevice</a>.</p>

</div>
</div>
<a id="a7e390c25a4ca7e70a58e8c14ffc0e37e" name="a7e390c25a4ca7e70a58e8c14ffc0e37e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e390c25a4ca7e70a58e8c14ffc0e37e">&#9670;&nbsp;</a></span>bufferQueue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFactory , typename TSurface , typename TGraphicsAdapter , typename TSwapChain , typename TCommandQueue , typename TRenderPass , typename TFrameBuffer  = TRenderPass::frame_buffer_type, typename TRenderPipeline  = TRenderPass::render_pipeline_type, typename TInputAttachmentMapping  = TRenderPass::input_attachment_mapping_type, typename TCommandBuffer  = TCommandQueue::command_buffer_type, typename TImage  = TFactory::image_type, typename TVertexBuffer  = TFactory::vertex_buffer_type, typename TIndexBuffer  = TFactory::index_buffer_type, typename TDescriptorLayout  = TFactory::descriptor_layout_type, typename TBuffer  = TFactory::buffer_type, typename TSampler  = TFactory::sampler_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const TCommandQueue &amp; <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html">LiteFX::Rendering::IGraphicsDevice</a>&lt; TFactory, TSurface, TGraphicsAdapter, TSwapChain, TCommandQueue, TRenderPass, TFrameBuffer, TRenderPipeline, TInputAttachmentMapping, TCommandBuffer, TImage, TVertexBuffer, TIndexBuffer, TDescriptorLayout, TBuffer, TSampler &gt;::bufferQueue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the instance of the queue used for host-device transfers. </p>
<p >Note that this can be the same as <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#aca7277b5f6e15ce232246f701d17a97b" title="Returns the instance of the queue, used to process draw calls.">graphicsQueue</a>, if no dedicated transfer queues are supported on the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The instance of the queue used for host-device transfers.</dd></dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_device.html#aac05aed33372c6cc7ea7cb248cccf15e">LiteFX::Rendering::Backends::DirectX12Device</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_device.html#a75322981b05e0cdd7e85944f61a5575d">LiteFX::Rendering::Backends::VulkanDevice</a>.</p>

</div>
</div>
<a id="a4b64e41cd0022794bb47bb49712bee80" name="a4b64e41cd0022794bb47bb49712bee80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b64e41cd0022794bb47bb49712bee80">&#9670;&nbsp;</a></span>computeQueue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFactory , typename TSurface , typename TGraphicsAdapter , typename TSwapChain , typename TCommandQueue , typename TRenderPass , typename TFrameBuffer  = TRenderPass::frame_buffer_type, typename TRenderPipeline  = TRenderPass::render_pipeline_type, typename TInputAttachmentMapping  = TRenderPass::input_attachment_mapping_type, typename TCommandBuffer  = TCommandQueue::command_buffer_type, typename TImage  = TFactory::image_type, typename TVertexBuffer  = TFactory::vertex_buffer_type, typename TIndexBuffer  = TFactory::index_buffer_type, typename TDescriptorLayout  = TFactory::descriptor_layout_type, typename TBuffer  = TFactory::buffer_type, typename TSampler  = TFactory::sampler_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const TCommandQueue &amp; <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html">LiteFX::Rendering::IGraphicsDevice</a>&lt; TFactory, TSurface, TGraphicsAdapter, TSwapChain, TCommandQueue, TRenderPass, TFrameBuffer, TRenderPipeline, TInputAttachmentMapping, TCommandBuffer, TImage, TVertexBuffer, TIndexBuffer, TDescriptorLayout, TBuffer, TSampler &gt;::computeQueue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the instance of the queue used for compute calls. </p>
<p >Note that this can be the same as <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#aca7277b5f6e15ce232246f701d17a97b" title="Returns the instance of the queue, used to process draw calls.">graphicsQueue</a>, if no dedicated compute queues are supported on the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The instance of the queue used for compute calls.</dd></dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_device.html#a78c054650aed8405e24ef468b7741874">LiteFX::Rendering::Backends::DirectX12Device</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_device.html#aacb8958e48cc952538aebf220c8bb68e">LiteFX::Rendering::Backends::VulkanDevice</a>.</p>

</div>
</div>
<a id="a430dfbe808b706d594590f0ccddb4fba" name="a430dfbe808b706d594590f0ccddb4fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a430dfbe808b706d594590f0ccddb4fba">&#9670;&nbsp;</a></span>factory()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFactory , typename TSurface , typename TGraphicsAdapter , typename TSwapChain , typename TCommandQueue , typename TRenderPass , typename TFrameBuffer  = TRenderPass::frame_buffer_type, typename TRenderPipeline  = TRenderPass::render_pipeline_type, typename TInputAttachmentMapping  = TRenderPass::input_attachment_mapping_type, typename TCommandBuffer  = TCommandQueue::command_buffer_type, typename TImage  = TFactory::image_type, typename TVertexBuffer  = TFactory::vertex_buffer_type, typename TIndexBuffer  = TFactory::index_buffer_type, typename TDescriptorLayout  = TFactory::descriptor_layout_type, typename TBuffer  = TFactory::buffer_type, typename TSampler  = TFactory::sampler_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const TFactory &amp; <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html">LiteFX::Rendering::IGraphicsDevice</a>&lt; TFactory, TSurface, TGraphicsAdapter, TSwapChain, TCommandQueue, TRenderPass, TFrameBuffer, TRenderPipeline, TInputAttachmentMapping, TCommandBuffer, TImage, TVertexBuffer, TIndexBuffer, TDescriptorLayout, TBuffer, TSampler &gt;::factory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the factory instance, used to create instances from the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The factory instance, used to create instances from the device.</dd></dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_device.html#abf5dc9be02003b2bd7385f1d02aed10f">LiteFX::Rendering::Backends::DirectX12Device</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_device.html#a15e5d82e0136608a9a69d900f7b76302">LiteFX::Rendering::Backends::VulkanDevice</a>.</p>

</div>
</div>
<a id="aca7277b5f6e15ce232246f701d17a97b" name="aca7277b5f6e15ce232246f701d17a97b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca7277b5f6e15ce232246f701d17a97b">&#9670;&nbsp;</a></span>graphicsQueue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFactory , typename TSurface , typename TGraphicsAdapter , typename TSwapChain , typename TCommandQueue , typename TRenderPass , typename TFrameBuffer  = TRenderPass::frame_buffer_type, typename TRenderPipeline  = TRenderPass::render_pipeline_type, typename TInputAttachmentMapping  = TRenderPass::input_attachment_mapping_type, typename TCommandBuffer  = TCommandQueue::command_buffer_type, typename TImage  = TFactory::image_type, typename TVertexBuffer  = TFactory::vertex_buffer_type, typename TIndexBuffer  = TFactory::index_buffer_type, typename TDescriptorLayout  = TFactory::descriptor_layout_type, typename TBuffer  = TFactory::buffer_type, typename TSampler  = TFactory::sampler_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const TCommandQueue &amp; <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html">LiteFX::Rendering::IGraphicsDevice</a>&lt; TFactory, TSurface, TGraphicsAdapter, TSwapChain, TCommandQueue, TRenderPass, TFrameBuffer, TRenderPipeline, TInputAttachmentMapping, TCommandBuffer, TImage, TVertexBuffer, TIndexBuffer, TDescriptorLayout, TBuffer, TSampler &gt;::graphicsQueue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the instance of the queue, used to process draw calls. </p>
<dl class="section return"><dt>Returns</dt><dd>The instance of the queue, used to process draw calls.</dd></dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_device.html#a7b05bfb125bafc8cd99dc24ef8d94efe">LiteFX::Rendering::Backends::DirectX12Device</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_device.html#ad0856576709ee3a9917e56d40d8977fc">LiteFX::Rendering::Backends::VulkanDevice</a>.</p>

</div>
</div>
<a id="a29cfb8f4df1969b816781a2a1ccf9675" name="a29cfb8f4df1969b816781a2a1ccf9675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29cfb8f4df1969b816781a2a1ccf9675">&#9670;&nbsp;</a></span>maximumMultiSamplingLevel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFactory , typename TSurface , typename TGraphicsAdapter , typename TSwapChain , typename TCommandQueue , typename TRenderPass , typename TFrameBuffer  = TRenderPass::frame_buffer_type, typename TRenderPipeline  = TRenderPass::render_pipeline_type, typename TInputAttachmentMapping  = TRenderPass::input_attachment_mapping_type, typename TCommandBuffer  = TCommandQueue::command_buffer_type, typename TImage  = TFactory::image_type, typename TVertexBuffer  = TFactory::vertex_buffer_type, typename TIndexBuffer  = TFactory::index_buffer_type, typename TDescriptorLayout  = TFactory::descriptor_layout_type, typename TBuffer  = TFactory::buffer_type, typename TSampler  = TFactory::sampler_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual MultiSamplingLevel <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html">LiteFX::Rendering::IGraphicsDevice</a>&lt; TFactory, TSurface, TGraphicsAdapter, TSwapChain, TCommandQueue, TRenderPass, TFrameBuffer, TRenderPipeline, TInputAttachmentMapping, TCommandBuffer, TImage, TVertexBuffer, TIndexBuffer, TDescriptorLayout, TBuffer, TSampler &gt;::maximumMultiSamplingLevel </td>
          <td>(</td>
          <td class="paramtype">const Format &amp;&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queries the device for the maximum supported number of multi-sampling levels. </p>
<p >This method returns the maximum supported multi-sampling level for a certain format. Typically you want to pass a back-buffer format for your swap-chain here. All lower multi-sampling levels are implicitly supported for this format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>The target (i.e. back-buffer) format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum multi-sampling level.</dd></dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_device.html#a3d79e7d0bd4ee634cb1ff95d43b8519d">LiteFX::Rendering::Backends::DirectX12Device</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_device.html#a3d40489b413a5c6c7d16bf7e7352b229">LiteFX::Rendering::Backends::VulkanDevice</a>.</p>

</div>
</div>
<a id="a09a6413f74e5070d12ade6db1fd80fcc" name="a09a6413f74e5070d12ade6db1fd80fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09a6413f74e5070d12ade6db1fd80fcc">&#9670;&nbsp;</a></span>surface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFactory , typename TSurface , typename TGraphicsAdapter , typename TSwapChain , typename TCommandQueue , typename TRenderPass , typename TFrameBuffer  = TRenderPass::frame_buffer_type, typename TRenderPipeline  = TRenderPass::render_pipeline_type, typename TInputAttachmentMapping  = TRenderPass::input_attachment_mapping_type, typename TCommandBuffer  = TCommandQueue::command_buffer_type, typename TImage  = TFactory::image_type, typename TVertexBuffer  = TFactory::vertex_buffer_type, typename TIndexBuffer  = TFactory::index_buffer_type, typename TDescriptorLayout  = TFactory::descriptor_layout_type, typename TBuffer  = TFactory::buffer_type, typename TSampler  = TFactory::sampler_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const TSurface &amp; <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html">LiteFX::Rendering::IGraphicsDevice</a>&lt; TFactory, TSurface, TGraphicsAdapter, TSwapChain, TCommandQueue, TRenderPass, TFrameBuffer, TRenderPipeline, TInputAttachmentMapping, TCommandBuffer, TImage, TVertexBuffer, TIndexBuffer, TDescriptorLayout, TBuffer, TSampler &gt;::surface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the surface, the device draws to. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference of the surface, the device draws to.</dd></dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_device.html#aae7b40c0ec9704f506dc3277196c91bc">LiteFX::Rendering::Backends::DirectX12Device</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_device.html#a974c93e1c5766f13eabda8b35531ec0a">LiteFX::Rendering::Backends::VulkanDevice</a>.</p>

</div>
</div>
<a id="af07714bbea25139269950bd56daa015a" name="af07714bbea25139269950bd56daa015a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af07714bbea25139269950bd56daa015a">&#9670;&nbsp;</a></span>swapChain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFactory , typename TSurface , typename TGraphicsAdapter , typename TSwapChain , typename TCommandQueue , typename TRenderPass , typename TFrameBuffer  = TRenderPass::frame_buffer_type, typename TRenderPipeline  = TRenderPass::render_pipeline_type, typename TInputAttachmentMapping  = TRenderPass::input_attachment_mapping_type, typename TCommandBuffer  = TCommandQueue::command_buffer_type, typename TImage  = TFactory::image_type, typename TVertexBuffer  = TFactory::vertex_buffer_type, typename TIndexBuffer  = TFactory::index_buffer_type, typename TDescriptorLayout  = TFactory::descriptor_layout_type, typename TBuffer  = TFactory::buffer_type, typename TSampler  = TFactory::sampler_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const TSwapChain &amp; <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html">LiteFX::Rendering::IGraphicsDevice</a>&lt; TFactory, TSurface, TGraphicsAdapter, TSwapChain, TCommandQueue, TRenderPass, TFrameBuffer, TRenderPipeline, TInputAttachmentMapping, TCommandBuffer, TImage, TVertexBuffer, TIndexBuffer, TDescriptorLayout, TBuffer, TSampler &gt;::swapChain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the swap chain, that contains the back and front buffers used for presentation. </p>
<dl class="section return"><dt>Returns</dt><dd>The swap chain, that contains the back and front buffers used for presentation.</dd></dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_device.html#aeefc0cb0fc732a86f87167b30d8d279c">LiteFX::Rendering::Backends::DirectX12Device</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_device.html#a9d2c3db5ec2cd4f9a5e7fdcc7404efe5">LiteFX::Rendering::Backends::VulkanDevice</a>.</p>

</div>
</div>
<a id="a132a6c39e93fd7d0f692b7982b1c8abf" name="a132a6c39e93fd7d0f692b7982b1c8abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a132a6c39e93fd7d0f692b7982b1c8abf">&#9670;&nbsp;</a></span>transferQueue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFactory , typename TSurface , typename TGraphicsAdapter , typename TSwapChain , typename TCommandQueue , typename TRenderPass , typename TFrameBuffer  = TRenderPass::frame_buffer_type, typename TRenderPipeline  = TRenderPass::render_pipeline_type, typename TInputAttachmentMapping  = TRenderPass::input_attachment_mapping_type, typename TCommandBuffer  = TCommandQueue::command_buffer_type, typename TImage  = TFactory::image_type, typename TVertexBuffer  = TFactory::vertex_buffer_type, typename TIndexBuffer  = TFactory::index_buffer_type, typename TDescriptorLayout  = TFactory::descriptor_layout_type, typename TBuffer  = TFactory::buffer_type, typename TSampler  = TFactory::sampler_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const TCommandQueue &amp; <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html">LiteFX::Rendering::IGraphicsDevice</a>&lt; TFactory, TSurface, TGraphicsAdapter, TSwapChain, TCommandQueue, TRenderPass, TFrameBuffer, TRenderPipeline, TInputAttachmentMapping, TCommandBuffer, TImage, TVertexBuffer, TIndexBuffer, TDescriptorLayout, TBuffer, TSampler &gt;::transferQueue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the instance of the queue used for device-device transfers (e.g. between render-passes). </p>
<p >Note that this can be the same as <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#aca7277b5f6e15ce232246f701d17a97b" title="Returns the instance of the queue, used to process draw calls.">graphicsQueue</a>, if no dedicated transfer queues are supported on the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The instance of the queue used for device-device transfers (e.g. between render-passes).</dd></dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_device.html#ab02c3544c77f320ba863df8d4eae6719">LiteFX::Rendering::Backends::DirectX12Device</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_device.html#a3c3f40b6b913e47c2644e8ef0a9cd2ea">LiteFX::Rendering::Backends::VulkanDevice</a>.</p>

</div>
</div>
<a id="a1cc74be39636c093c3db1d45e3d0e28d" name="a1cc74be39636c093c3db1d45e3d0e28d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cc74be39636c093c3db1d45e3d0e28d">&#9670;&nbsp;</a></span>wait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFactory , typename TSurface , typename TGraphicsAdapter , typename TSwapChain , typename TCommandQueue , typename TRenderPass , typename TFrameBuffer  = TRenderPass::frame_buffer_type, typename TRenderPipeline  = TRenderPass::render_pipeline_type, typename TInputAttachmentMapping  = TRenderPass::input_attachment_mapping_type, typename TCommandBuffer  = TCommandQueue::command_buffer_type, typename TImage  = TFactory::image_type, typename TVertexBuffer  = TFactory::vertex_buffer_type, typename TIndexBuffer  = TFactory::index_buffer_type, typename TDescriptorLayout  = TFactory::descriptor_layout_type, typename TBuffer  = TFactory::buffer_type, typename TSampler  = TFactory::sampler_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html">LiteFX::Rendering::IGraphicsDevice</a>&lt; TFactory, TSurface, TGraphicsAdapter, TSwapChain, TCommandQueue, TRenderPass, TFrameBuffer, TRenderPipeline, TInputAttachmentMapping, TCommandBuffer, TImage, TVertexBuffer, TIndexBuffer, TDescriptorLayout, TBuffer, TSampler &gt;::wait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits until the device is idle. </p>
<p >The complexity of this operation may depend on the graphics API that implements this method. Calling this method guarantees, that the device resources are in an unused state and may safely be released. </p>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_device.html#a18385b5128d2e832d34e6c71d0ab0650">LiteFX::Rendering::Backends::DirectX12Device</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_device.html#a140db81d753df1283210c2eb274f5831">LiteFX::Rendering::Backends::VulkanDevice</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_lite_f_x.html">LiteFX</a></li><li class="navelem"><a class="el" href="namespace_lite_f_x_1_1_rendering.html">Rendering</a></li><li class="navelem"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html">IGraphicsDevice</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
