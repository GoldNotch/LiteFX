<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LiteFX: LiteFX::Rendering::ICommandBuffer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo_xs.png"/></td>
  <td id="projectalign">
   <div id="projectname">LiteFX<span id="projectnumber">&#160;0.3.1.2022</span>
   </div>
   <div id="projectbrief">Computer Graphics Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">LiteFX::Rendering::ICommandBuffer Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>The interface for a command buffer.  
 <a href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="rendering__api_8hpp_source.html">rendering_api.hpp</a>&gt;</code></p>

<p>Inherited by <a class="el" href="class_lite_f_x_1_1_rendering_1_1_command_buffer.html">LiteFX::Rendering::CommandBuffer&lt; IDirectX12Buffer, IDirectX12VertexBuffer, IDirectX12IndexBuffer, IDirectX12Image, DirectX12Barrier, DirectX12PipelineState &gt;</a>, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_command_buffer.html">LiteFX::Rendering::CommandBuffer&lt; IVulkanBuffer, IVulkanVertexBuffer, IVulkanIndexBuffer, IVulkanImage, VulkanBarrier, VulkanPipelineState &gt;</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_command_buffer.html">LiteFX::Rendering::CommandBuffer&lt; TBuffer, TVertexBuffer, TIndexBuffer, TImage, TBarrier, TPipeline &gt;</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac37242e5c15a3a6c0e74ad56b46e4aa2"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#ac37242e5c15a3a6c0e74ad56b46e4aa2">~ICommandBuffer</a> () noexcept=default</td></tr>
<tr class="separator:ac37242e5c15a3a6c0e74ad56b46e4aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08533dccdc780f870b9a5895aa3633b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#ad08533dccdc780f870b9a5895aa3633b">begin</a> () const =0</td></tr>
<tr class="memdesc:ad08533dccdc780f870b9a5895aa3633b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the command buffer into recording state, so that it can receive command that should be submitted to the parent <a class="el" href="class_lite_f_x_1_1_rendering_1_1_command_queue.html" title="Represents a command queue.">CommandQueue</a>.  <a href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#ad08533dccdc780f870b9a5895aa3633b">More...</a><br /></td></tr>
<tr class="separator:ad08533dccdc780f870b9a5895aa3633b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657800c43445c3ac118037d478a0d9d3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#a657800c43445c3ac118037d478a0d9d3">end</a> () const =0</td></tr>
<tr class="memdesc:a657800c43445c3ac118037d478a0d9d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends recording commands on the command buffer.  <a href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#a657800c43445c3ac118037d478a0d9d3">More...</a><br /></td></tr>
<tr class="separator:a657800c43445c3ac118037d478a0d9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333e6549e68b814cbf4c1b6536c040d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#a333e6549e68b814cbf4c1b6536c040d7">barrier</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_barrier.html">IBarrier</a> &amp;barrier, const bool &amp;invert=false) const noexcept</td></tr>
<tr class="memdesc:a333e6549e68b814cbf4c1b6536c040d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the transitions that have been added to <em>barrier</em> .  <a href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#a333e6549e68b814cbf4c1b6536c040d7">More...</a><br /></td></tr>
<tr class="separator:a333e6549e68b814cbf4c1b6536c040d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8bbc86565c70c2c61bde6d27ea7e5ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#aa8bbc86565c70c2c61bde6d27ea7e5ca">generateMipMaps</a> (<a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_image.html">IImage</a> &amp;image) noexcept</td></tr>
<tr class="memdesc:aa8bbc86565c70c2c61bde6d27ea7e5ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the image at level <em>0</em> to generate mip-maps for the remaining levels.  <a href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#aa8bbc86565c70c2c61bde6d27ea7e5ca">More...</a><br /></td></tr>
<tr class="separator:aa8bbc86565c70c2c61bde6d27ea7e5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c6a7803a81432f7aa76e8a12c8ad0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#a77c6a7803a81432f7aa76e8a12c8ad0d">transfer</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;source, const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;target, const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;sourceElement=0, const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;targetElement=0, const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;elements=1) const</td></tr>
<tr class="memdesc:a77c6a7803a81432f7aa76e8a12c8ad0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a buffer-to-buffer transfer from <em>source</em>  to <em>target</em> .  <a href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#a77c6a7803a81432f7aa76e8a12c8ad0d">More...</a><br /></td></tr>
<tr class="separator:a77c6a7803a81432f7aa76e8a12c8ad0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e8ae4315a26e4e985c9775e6321ca2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#af4e8ae4315a26e4e985c9775e6321ca2">transfer</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;source, const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_image.html">IImage</a> &amp;target, const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;sourceElement=0, const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;firstSubresource=0, const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;elements=1) const</td></tr>
<tr class="memdesc:af4e8ae4315a26e4e985c9775e6321ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a buffer-to-image transfer from <em>source</em>  to <em>target</em> .  <a href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#af4e8ae4315a26e4e985c9775e6321ca2">More...</a><br /></td></tr>
<tr class="separator:af4e8ae4315a26e4e985c9775e6321ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9fce72840f4a032ec6827ecc42e2d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#a1c9fce72840f4a032ec6827ecc42e2d5">transfer</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_image.html">IImage</a> &amp;source, const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_image.html">IImage</a> &amp;target, const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;sourceSubresource=0, const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;targetSubresource=0, const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;subresources=1) const</td></tr>
<tr class="memdesc:a1c9fce72840f4a032ec6827ecc42e2d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an image-to-image transfer from <em>source</em>  to <em>target</em> .  <a href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#a1c9fce72840f4a032ec6827ecc42e2d5">More...</a><br /></td></tr>
<tr class="separator:a1c9fce72840f4a032ec6827ecc42e2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b6f61f7de74832f96523e15184aa6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#a09b6f61f7de74832f96523e15184aa6f">transfer</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_image.html">IImage</a> &amp;source, const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;target, const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;firstSubresource=0, const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;targetElement=0, const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;subresources=1) const</td></tr>
<tr class="memdesc:a09b6f61f7de74832f96523e15184aa6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an image-to-buffer transfer from <em>source</em>  to <em>target</em> .  <a href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#a09b6f61f7de74832f96523e15184aa6f">More...</a><br /></td></tr>
<tr class="separator:a09b6f61f7de74832f96523e15184aa6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81dad499f968cc318887b5de2c88e237"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#a81dad499f968cc318887b5de2c88e237">use</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_pipeline.html">IPipeline</a> &amp;pipeline) const noexcept</td></tr>
<tr class="memdesc:a81dad499f968cc318887b5de2c88e237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the active pipeline state.  <a href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#a81dad499f968cc318887b5de2c88e237">More...</a><br /></td></tr>
<tr class="separator:a81dad499f968cc318887b5de2c88e237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e0e6f172595e3d518abb8f7a4c029c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#a16e0e6f172595e3d518abb8f7a4c029c">bind</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_descriptor_set.html">IDescriptorSet</a> &amp;descriptorSet, const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_pipeline.html">IPipeline</a> &amp;pipeline) const noexcept</td></tr>
<tr class="memdesc:a16e0e6f172595e3d518abb8f7a4c029c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds the provided descriptor set to the provided pipeline.  <a href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#a16e0e6f172595e3d518abb8f7a4c029c">More...</a><br /></td></tr>
<tr class="separator:a16e0e6f172595e3d518abb8f7a4c029c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb21afb1d781eb09ac5b66469254319c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#aeb21afb1d781eb09ac5b66469254319c">bind</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_vertex_buffer.html">IVertexBuffer</a> &amp;buffer) const noexcept</td></tr>
<tr class="memdesc:aeb21afb1d781eb09ac5b66469254319c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds a vertex buffer to the pipeline.  <a href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#aeb21afb1d781eb09ac5b66469254319c">More...</a><br /></td></tr>
<tr class="separator:aeb21afb1d781eb09ac5b66469254319c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a4c24ba2faed5f22e70780990d47f8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#a7a4c24ba2faed5f22e70780990d47f8d">bind</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_index_buffer.html">IIndexBuffer</a> &amp;buffer) const noexcept</td></tr>
<tr class="memdesc:a7a4c24ba2faed5f22e70780990d47f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds a index buffer to the pipeline.  <a href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#a7a4c24ba2faed5f22e70780990d47f8d">More...</a><br /></td></tr>
<tr class="separator:a7a4c24ba2faed5f22e70780990d47f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf435a6a14ee347e39d6e2a5e2b9d0d6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#aaf435a6a14ee347e39d6e2a5e2b9d0d6">dispatch</a> (const <a class="el" href="class_lite_f_x_1_1_math_1_1_vector3u.html">Vector3u</a> &amp;threadCount) const noexcept=0</td></tr>
<tr class="memdesc:aaf435a6a14ee347e39d6e2a5e2b9d0d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a compute shader.  <a href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#aaf435a6a14ee347e39d6e2a5e2b9d0d6">More...</a><br /></td></tr>
<tr class="separator:aaf435a6a14ee347e39d6e2a5e2b9d0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1832d98576c5a7c7f16d3ad07c6ff88"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#ac1832d98576c5a7c7f16d3ad07c6ff88">draw</a> (const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;vertices, const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;instances=1, const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;firstVertex=0, const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;firstInstance=0) const noexcept=0</td></tr>
<tr class="memdesc:ac1832d98576c5a7c7f16d3ad07c6ff88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a number of vertices from the currently bound vertex buffer.  <a href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#ac1832d98576c5a7c7f16d3ad07c6ff88">More...</a><br /></td></tr>
<tr class="separator:ac1832d98576c5a7c7f16d3ad07c6ff88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382b6e3f94e5bec9752e23782a4e237b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#a382b6e3f94e5bec9752e23782a4e237b">drawIndexed</a> (const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;indices, const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;instances=1, const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;firstIndex=0, const <a class="el" href="namespace_lite_f_x_1_1_math.html#a9f4ffb05daa7d2dd0a2a68c5b9971133">Int32</a> &amp;vertexOffset=0, const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;firstInstance=0) const noexcept=0</td></tr>
<tr class="memdesc:a382b6e3f94e5bec9752e23782a4e237b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws the currently bound vertex buffer with a set of indices from the currently bound index buffer.  <a href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#a382b6e3f94e5bec9752e23782a4e237b">More...</a><br /></td></tr>
<tr class="separator:a382b6e3f94e5bec9752e23782a4e237b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb85f4a22dc33f92d8d109f4ded1fc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#a9fb85f4a22dc33f92d8d109f4ded1fc2">pushConstants</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_push_constants_layout.html">IPushConstantsLayout</a> &amp;layout, const void *const memory) const noexcept</td></tr>
<tr class="memdesc:a9fb85f4a22dc33f92d8d109f4ded1fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes a block of memory into the push constants backing memory.  <a href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#a9fb85f4a22dc33f92d8d109f4ded1fc2">More...</a><br /></td></tr>
<tr class="separator:a9fb85f4a22dc33f92d8d109f4ded1fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3b2a58ddc6f02e793b65321c48ff21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#a6f3b2a58ddc6f02e793b65321c48ff21">draw</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_vertex_buffer.html">IVertexBuffer</a> &amp;vertexBuffer, const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;instances=1, const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;firstVertex=0, const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;firstInstance=0) const</td></tr>
<tr class="memdesc:a6f3b2a58ddc6f02e793b65321c48ff21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws all vertices from the vertex buffer provided in <em>vertexBuffer</em> .  <a href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#a6f3b2a58ddc6f02e793b65321c48ff21">More...</a><br /></td></tr>
<tr class="separator:a6f3b2a58ddc6f02e793b65321c48ff21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aeebd45f661aeaf09cd6284647b30fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#a1aeebd45f661aeaf09cd6284647b30fa">drawIndexed</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_index_buffer.html">IIndexBuffer</a> &amp;indexBuffer, const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;instances=1, const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;firstIndex=0, const <a class="el" href="namespace_lite_f_x_1_1_math.html#a9f4ffb05daa7d2dd0a2a68c5b9971133">Int32</a> &amp;vertexOffset=0, const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;firstInstance=0) const</td></tr>
<tr class="memdesc:a1aeebd45f661aeaf09cd6284647b30fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws the currently bound vertex buffer using the index buffer provided in <em>indexBuffer</em> .  <a href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#a1aeebd45f661aeaf09cd6284647b30fa">More...</a><br /></td></tr>
<tr class="separator:a1aeebd45f661aeaf09cd6284647b30fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708e099104272e8fbc765fadbf2699eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#a708e099104272e8fbc765fadbf2699eb">drawIndexed</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_vertex_buffer.html">IVertexBuffer</a> &amp;vertexBuffer, const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_index_buffer.html">IIndexBuffer</a> &amp;indexBuffer, const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;instances=1, const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;firstIndex=0, const <a class="el" href="namespace_lite_f_x_1_1_math.html#a9f4ffb05daa7d2dd0a2a68c5b9971133">Int32</a> &amp;vertexOffset=0, const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;firstInstance=0) const</td></tr>
<tr class="memdesc:a708e099104272e8fbc765fadbf2699eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws the vertex buffer provided by <em>vertexBuffer</em>  using the index buffer, provided by <em>indexBuffer</em> .  <a href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#a708e099104272e8fbc765fadbf2699eb">More...</a><br /></td></tr>
<tr class="separator:a708e099104272e8fbc765fadbf2699eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >The interface for a command buffer. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac37242e5c15a3a6c0e74ad56b46e4aa2" name="ac37242e5c15a3a6c0e74ad56b46e4aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac37242e5c15a3a6c0e74ad56b46e4aa2">&#9670;&nbsp;</a></span>~ICommandBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual LiteFX::Rendering::ICommandBuffer::~ICommandBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a333e6549e68b814cbf4c1b6536c040d7" name="a333e6549e68b814cbf4c1b6536c040d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a333e6549e68b814cbf4c1b6536c040d7">&#9670;&nbsp;</a></span>barrier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::barrier </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_barrier.html">IBarrier</a> &amp;&#160;</td>
          <td class="paramname"><em>barrier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>invert</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes the transitions that have been added to <em>barrier</em> . </p>
<p >Calling this method will also update the resource states of each resource within the barrier. However, the actual state of the resource does not change until the barrier is executed on the command queue. Keep this in mind when inserting multiple barriers from different threads or in different command buffers, which may not be executed in order. You might have to manually synchronize barrier execution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">barrier</td><td>The barrier containing the transitions to perform.</td></tr>
    <tr><td class="paramname">invert</td><td>If set to <code>true</code>, the barrier will perform a transition back to the original resource states.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad08533dccdc780f870b9a5895aa3633b" name="ad08533dccdc780f870b9a5895aa3633b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad08533dccdc780f870b9a5895aa3633b">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void LiteFX::Rendering::ICommandBuffer::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the command buffer into recording state, so that it can receive command that should be submitted to the parent <a class="el" href="class_lite_f_x_1_1_rendering_1_1_command_queue.html" title="Represents a command queue.">CommandQueue</a>. </p>
<p >Note that you have to wait for a command buffer to be executed on the parent <a class="el" href="class_lite_f_x_1_1_rendering_1_1_command_queue.html" title="Represents a command queue.">CommandQueue</a> before you can begin recording on it again. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">RuntimeException</td><td>Thrown, if the command buffer is already recording.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#a657800c43445c3ac118037d478a0d9d3" title="Ends recording commands on the command buffer.">end</a></dd></dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_command_buffer.html#a52eb140093df379bc743c18025869ab2">LiteFX::Rendering::Backends::DirectX12CommandBuffer</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_command_buffer.html#a3d992e05fabf1c2791c8965c5faac382">LiteFX::Rendering::Backends::VulkanCommandBuffer</a>.</p>

</div>
</div>
<a id="a16e0e6f172595e3d518abb8f7a4c029c" name="a16e0e6f172595e3d518abb8f7a4c029c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16e0e6f172595e3d518abb8f7a4c029c">&#9670;&nbsp;</a></span>bind() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::bind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_descriptor_set.html">IDescriptorSet</a> &amp;&#160;</td>
          <td class="paramname"><em>descriptorSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_pipeline.html">IPipeline</a> &amp;&#160;</td>
          <td class="paramname"><em>pipeline</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binds the provided descriptor set to the provided pipeline. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descriptorSet</td><td>The descriptor set to bind.</td></tr>
    <tr><td class="paramname">pipeline</td><td>The pipeline to bind the descriptor set to.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a4c24ba2faed5f22e70780990d47f8d" name="a7a4c24ba2faed5f22e70780990d47f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a4c24ba2faed5f22e70780990d47f8d">&#9670;&nbsp;</a></span>bind() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::bind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_index_buffer.html">IIndexBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binds a index buffer to the pipeline. </p>
<p >After binding the index buffer, the next call to <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#a382b6e3f94e5bec9752e23782a4e237b" title="Draws the currently bound vertex buffer with a set of indices from the currently bound index buffer.">drawIndexed</a> will read from it, until another index buffer is bound. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The index buffer to bind to the pipeline.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_lite_f_x_1_1_rendering_1_1_index_buffer.html" title="Describes an index buffer.">IndexBuffer</a>, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#a382b6e3f94e5bec9752e23782a4e237b" title="Draws the currently bound vertex buffer with a set of indices from the currently bound index buffer.">drawIndexed</a></dd></dl>

</div>
</div>
<a id="aeb21afb1d781eb09ac5b66469254319c" name="aeb21afb1d781eb09ac5b66469254319c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb21afb1d781eb09ac5b66469254319c">&#9670;&nbsp;</a></span>bind() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::bind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_vertex_buffer.html">IVertexBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binds a vertex buffer to the pipeline. </p>
<p >After binding the vertex buffer, the next call to <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#ac1832d98576c5a7c7f16d3ad07c6ff88" title="Draws a number of vertices from the currently bound vertex buffer.">draw</a> or <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#a382b6e3f94e5bec9752e23782a4e237b" title="Draws the currently bound vertex buffer with a set of indices from the currently bound index buffer.">drawIndexed</a> will read from it, until another vertex buffer is bound. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The vertex buffer to bind to the pipeline.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_lite_f_x_1_1_rendering_1_1_vertex_buffer.html" title="Describes a vertex buffer.">VertexBuffer</a>, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#ac1832d98576c5a7c7f16d3ad07c6ff88" title="Draws a number of vertices from the currently bound vertex buffer.">draw</a>, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#a382b6e3f94e5bec9752e23782a4e237b" title="Draws the currently bound vertex buffer with a set of indices from the currently bound index buffer.">drawIndexed</a></dd></dl>

</div>
</div>
<a id="aaf435a6a14ee347e39d6e2a5e2b9d0d6" name="aaf435a6a14ee347e39d6e2a5e2b9d0d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf435a6a14ee347e39d6e2a5e2b9d0d6">&#9670;&nbsp;</a></span>dispatch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void LiteFX::Rendering::ICommandBuffer::dispatch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_math_1_1_vector3u.html">Vector3u</a> &amp;&#160;</td>
          <td class="paramname"><em>threadCount</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes a compute shader. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threadCount</td><td>The number of thread groups per axis.</td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_command_buffer.html#a5a595df75528e08d2771a1a14fd08375">LiteFX::Rendering::Backends::DirectX12CommandBuffer</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_command_buffer.html#acf9b4596f4bc07fd90ce01e6b1585b5e">LiteFX::Rendering::Backends::VulkanCommandBuffer</a>.</p>

</div>
</div>
<a id="a6f3b2a58ddc6f02e793b65321c48ff21" name="a6f3b2a58ddc6f02e793b65321c48ff21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f3b2a58ddc6f02e793b65321c48ff21">&#9670;&nbsp;</a></span>draw() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::draw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_vertex_buffer.html">IVertexBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>vertexBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;&#160;</td>
          <td class="paramname"><em>instances</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;&#160;</td>
          <td class="paramname"><em>firstVertex</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;&#160;</td>
          <td class="paramname"><em>firstInstance</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws all vertices from the vertex buffer provided in <em>vertexBuffer</em> . </p>
<p >This helper method binds the vertex buffer and issues a draw command for all vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexBuffer</td><td>The vertex buffer to draw from.</td></tr>
    <tr><td class="paramname">instances</td><td>The number of instances to draw.</td></tr>
    <tr><td class="paramname">firstVertex</td><td>The index of the first vertex to start drawing from.</td></tr>
    <tr><td class="paramname">firstInstance</td><td>The index of the first instance to draw.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1832d98576c5a7c7f16d3ad07c6ff88" name="ac1832d98576c5a7c7f16d3ad07c6ff88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1832d98576c5a7c7f16d3ad07c6ff88">&#9670;&nbsp;</a></span>draw() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void LiteFX::Rendering::ICommandBuffer::draw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;&#160;</td>
          <td class="paramname"><em>instances</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;&#160;</td>
          <td class="paramname"><em>firstVertex</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;&#160;</td>
          <td class="paramname"><em>firstInstance</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a number of vertices from the currently bound vertex buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The number of vertices to draw.</td></tr>
    <tr><td class="paramname">instances</td><td>The number of instances to draw.</td></tr>
    <tr><td class="paramname">firstVertex</td><td>The index of the first vertex to start drawing from.</td></tr>
    <tr><td class="paramname">firstInstance</td><td>The index of the first instance to draw.</td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_command_buffer.html#a78f64ae040d4d33af6538d10979bfb80">LiteFX::Rendering::Backends::DirectX12CommandBuffer</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_command_buffer.html#aebd143cbcfefe3fef5d79f4030158ef0">LiteFX::Rendering::Backends::VulkanCommandBuffer</a>.</p>

</div>
</div>
<a id="a1aeebd45f661aeaf09cd6284647b30fa" name="a1aeebd45f661aeaf09cd6284647b30fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aeebd45f661aeaf09cd6284647b30fa">&#9670;&nbsp;</a></span>drawIndexed() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::drawIndexed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_index_buffer.html">IIndexBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>indexBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;&#160;</td>
          <td class="paramname"><em>instances</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;&#160;</td>
          <td class="paramname"><em>firstIndex</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x_1_1_math.html#a9f4ffb05daa7d2dd0a2a68c5b9971133">Int32</a> &amp;&#160;</td>
          <td class="paramname"><em>vertexOffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;&#160;</td>
          <td class="paramname"><em>firstInstance</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws the currently bound vertex buffer using the index buffer provided in <em>indexBuffer</em> . </p>
<p >This helper method binds the index buffer and issues a draw command for all indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexBuffer</td><td>The index buffer to draw with.</td></tr>
    <tr><td class="paramname">instances</td><td>The number of instances to draw.</td></tr>
    <tr><td class="paramname">firstIndex</td><td>The index of the first element of the index buffer to start drawing from.</td></tr>
    <tr><td class="paramname">vertexOffset</td><td>The offset added to each index to find the corresponding vertex.</td></tr>
    <tr><td class="paramname">firstInstance</td><td>The index of the first instance to draw.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a708e099104272e8fbc765fadbf2699eb" name="a708e099104272e8fbc765fadbf2699eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a708e099104272e8fbc765fadbf2699eb">&#9670;&nbsp;</a></span>drawIndexed() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::drawIndexed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_vertex_buffer.html">IVertexBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>vertexBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_index_buffer.html">IIndexBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>indexBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;&#160;</td>
          <td class="paramname"><em>instances</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;&#160;</td>
          <td class="paramname"><em>firstIndex</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x_1_1_math.html#a9f4ffb05daa7d2dd0a2a68c5b9971133">Int32</a> &amp;&#160;</td>
          <td class="paramname"><em>vertexOffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;&#160;</td>
          <td class="paramname"><em>firstInstance</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws the vertex buffer provided by <em>vertexBuffer</em>  using the index buffer, provided by <em>indexBuffer</em> . </p>
<p >This helper method binds the provided vertex and index buffers and issues a draw command for all indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexBuffer</td><td>The vertex buffer to draw from.</td></tr>
    <tr><td class="paramname">indexBuffer</td><td>The index buffer to draw with.</td></tr>
    <tr><td class="paramname">instances</td><td>The number of instances to draw.</td></tr>
    <tr><td class="paramname">firstIndex</td><td>The index of the first element of the index buffer to start drawing from.</td></tr>
    <tr><td class="paramname">vertexOffset</td><td>The offset added to each index to find the corresponding vertex.</td></tr>
    <tr><td class="paramname">firstInstance</td><td>The index of the first instance to draw.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a382b6e3f94e5bec9752e23782a4e237b" name="a382b6e3f94e5bec9752e23782a4e237b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a382b6e3f94e5bec9752e23782a4e237b">&#9670;&nbsp;</a></span>drawIndexed() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void LiteFX::Rendering::ICommandBuffer::drawIndexed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;&#160;</td>
          <td class="paramname"><em>instances</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;&#160;</td>
          <td class="paramname"><em>firstIndex</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x_1_1_math.html#a9f4ffb05daa7d2dd0a2a68c5b9971133">Int32</a> &amp;&#160;</td>
          <td class="paramname"><em>vertexOffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;&#160;</td>
          <td class="paramname"><em>firstInstance</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws the currently bound vertex buffer with a set of indices from the currently bound index buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>The number of indices to draw.</td></tr>
    <tr><td class="paramname">instances</td><td>The number of instances to draw.</td></tr>
    <tr><td class="paramname">firstIndex</td><td>The index of the first element of the index buffer to start drawing from.</td></tr>
    <tr><td class="paramname">vertexOffset</td><td>The offset added to each index to find the corresponding vertex.</td></tr>
    <tr><td class="paramname">firstInstance</td><td>The index of the first instance to draw.</td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_command_buffer.html#a00c6592fceb092789bc6199742e73906">LiteFX::Rendering::Backends::DirectX12CommandBuffer</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_command_buffer.html#af0c65f86c927d7596c60ea8689ce06b1">LiteFX::Rendering::Backends::VulkanCommandBuffer</a>.</p>

</div>
</div>
<a id="a657800c43445c3ac118037d478a0d9d3" name="a657800c43445c3ac118037d478a0d9d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657800c43445c3ac118037d478a0d9d3">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void LiteFX::Rendering::ICommandBuffer::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ends recording commands on the command buffer. </p>
<p >It is valid to call this method multiple times. If a command buffer is already closed, nothing will happen. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html#ad08533dccdc780f870b9a5895aa3633b" title="Sets the command buffer into recording state, so that it can receive command that should be submitted...">begin</a></dd></dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_command_buffer.html#a862deed4385cf89496cc8e9c2ddde70f">LiteFX::Rendering::Backends::DirectX12CommandBuffer</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_command_buffer.html#a2db74c40d8532bdf9eeec8debe134d3a">LiteFX::Rendering::Backends::VulkanCommandBuffer</a>.</p>

</div>
</div>
<a id="aa8bbc86565c70c2c61bde6d27ea7e5ca" name="aa8bbc86565c70c2c61bde6d27ea7e5ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8bbc86565c70c2c61bde6d27ea7e5ca">&#9670;&nbsp;</a></span>generateMipMaps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::generateMipMaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_image.html">IImage</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uses the image at level <em>0</em> to generate mip-maps for the remaining levels. </p>
<p >It is strongly advised, not to generate mip maps at runtime. Instead, prefer using a format that supports pre-computed mip maps. If you have to, prefer computing mip maps in a pre-process.</p>
<p >Note that not all texture formats and sizes are supported for mip map generation and the result might not be satisfactory. For example, it is not possible to compute proper mip maps for pre-compressed formats. Textures should have power of two sizes in order to not appear under-sampled.</p>
<p >Note that generating mip maps might require the texture to be writable. You can transfer the texture into a non-writable resource afterwards to improve performance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandBuffer</td><td>The command buffer used to issue the transition and transfer operations.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9fb85f4a22dc33f92d8d109f4ded1fc2" name="a9fb85f4a22dc33f92d8d109f4ded1fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb85f4a22dc33f92d8d109f4ded1fc2">&#9670;&nbsp;</a></span>pushConstants()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::pushConstants </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_push_constants_layout.html">IPushConstantsLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pushes a block of memory into the push constants backing memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layout</td><td>The layout of the push constants to update.</td></tr>
    <tr><td class="paramname">memory</td><td>A pointer to the source memory.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77c6a7803a81432f7aa76e8a12c8ad0d" name="a77c6a7803a81432f7aa76e8a12c8ad0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77c6a7803a81432f7aa76e8a12c8ad0d">&#9670;&nbsp;</a></span>transfer() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::transfer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceElement</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;&#160;</td>
          <td class="paramname"><em>targetElement</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;&#160;</td>
          <td class="paramname"><em>elements</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a buffer-to-buffer transfer from <em>source</em>  to <em>target</em> . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source buffer to transfer data from.</td></tr>
    <tr><td class="paramname">target</td><td>The target buffer to transfer data to.</td></tr>
    <tr><td class="paramname">sourceElement</td><td>The index of the first element in the source buffer to copy.</td></tr>
    <tr><td class="paramname">targetElement</td><td>The index of the first element in the target buffer to copy to.</td></tr>
    <tr><td class="paramname">elements</td><td>The number of elements to copy from the source buffer into the target buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentOutOfRangeException</td><td>Thrown, if the number of either the source buffer or the target buffer has not enough elements for the specified <em>elements</em>  parameter.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af4e8ae4315a26e4e985c9775e6321ca2" name="af4e8ae4315a26e4e985c9775e6321ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4e8ae4315a26e4e985c9775e6321ca2">&#9670;&nbsp;</a></span>transfer() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::transfer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_image.html">IImage</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceElement</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;&#160;</td>
          <td class="paramname"><em>firstSubresource</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;&#160;</td>
          <td class="paramname"><em>elements</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a buffer-to-image transfer from <em>source</em>  to <em>target</em> . </p>
<p >The <em>subresource</em>  parameter describes the index of the first sub-resource to copy. Each element gets copied into the subsequent sub-resource, where resources are counted in the following order:</p>
<ul>
<li>
Level Contains the mip-map levels.  </li>
<li>
Layer Contains the array slices.  </li>
<li>
Plane Contains planes for multi-planar formats.  </li>
</ul>
<p >E.g., if 6 elements should be copied to an image with 3 mip-map levels and 3 layers, the elements 0-2 contain the mip-map levels of the first layer, while elements 3-5 contain the three mip-map levels of the second layer. The third layer would not receive any data in this example. If the image format has multiple planes, this procedure would be repeated for each plane, however one buffer element only maps to one sub-resource. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source buffer to transfer data from.</td></tr>
    <tr><td class="paramname">target</td><td>The target image to transfer data to.</td></tr>
    <tr><td class="paramname">sourceElement</td><td>The index of the first element in the source buffer to copy.</td></tr>
    <tr><td class="paramname">firstSubresource</td><td>The index of the first sub-resource of the target image to receive data.</td></tr>
    <tr><td class="paramname">elements</td><td>The number of elements to copy from the source buffer into the target image sub-resources.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentOutOfRangeException</td><td>Thrown, if the number of either the source buffer or the target buffer has not enough elements for the specified <em>elements</em>  parameter.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09b6f61f7de74832f96523e15184aa6f" name="a09b6f61f7de74832f96523e15184aa6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b6f61f7de74832f96523e15184aa6f">&#9670;&nbsp;</a></span>transfer() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::transfer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_image.html">IImage</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;&#160;</td>
          <td class="paramname"><em>firstSubresource</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;&#160;</td>
          <td class="paramname"><em>targetElement</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;&#160;</td>
          <td class="paramname"><em>subresources</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an image-to-buffer transfer from <em>source</em>  to <em>target</em> . </p>
<p >The <em>firstSubresource</em>  parameter describes the index of the first sub-resource to copy. Each element gets copied into the subsequent sub-resource, where resources are counted in the following order:</p>
<ul>
<li>
Level Contains the mip-map levels.  </li>
<li>
Layer Contains the array slices.  </li>
<li>
Plane Contains planes for multi-planar formats.  </li>
</ul>
<p >E.g., if 6 elements should be copied to an image with 3 mip-map levels and 3 layers, the elements 0-2 contain the mip-map levels of the first layer, while elements 3-5 contain the three mip-map levels of the second layer. The third layer would not receive any data in this example. If the image format has multiple planes, this procedure would be repeated for each plane, however one buffer element only maps to one sub-resource. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source image to transfer data from.</td></tr>
    <tr><td class="paramname">target</td><td>The target buffer to transfer data to.</td></tr>
    <tr><td class="paramname">firstSubresource</td><td>The index of the first sub-resource to copy from the source image.</td></tr>
    <tr><td class="paramname">targetElement</td><td>The index of the first target element to receive data.</td></tr>
    <tr><td class="paramname">subresources</td><td>The number of sub-resources to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentOutOfRangeException</td><td>Thrown, if the number of either the source buffer or the target buffer has not enough elements for the specified <em>elements</em>  parameter.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c9fce72840f4a032ec6827ecc42e2d5" name="a1c9fce72840f4a032ec6827ecc42e2d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c9fce72840f4a032ec6827ecc42e2d5">&#9670;&nbsp;</a></span>transfer() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::transfer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_image.html">IImage</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_image.html">IImage</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceSubresource</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;&#160;</td>
          <td class="paramname"><em>targetSubresource</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> &amp;&#160;</td>
          <td class="paramname"><em>subresources</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an image-to-image transfer from <em>source</em>  to <em>target</em> . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source image to transfer data from.</td></tr>
    <tr><td class="paramname">target</td><td>The target image to transfer data to.</td></tr>
    <tr><td class="paramname">sourceSubresource</td><td>The index of the first sub-resource to copy from the source image.</td></tr>
    <tr><td class="paramname">targetSubresource</td><td>The image of the first sub-resource in the target image to receive data.</td></tr>
    <tr><td class="paramname">subresources</td><td>The number of sub-resources to copy between the images.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentOutOfRangeException</td><td>Thrown, if the number of either the source buffer or the target buffer has not enough elements for the specified <em>elements</em>  parameter.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81dad499f968cc318887b5de2c88e237" name="a81dad499f968cc318887b5de2c88e237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81dad499f968cc318887b5de2c88e237">&#9670;&nbsp;</a></span>use()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::use </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_pipeline.html">IPipeline</a> &amp;&#160;</td>
          <td class="paramname"><em>pipeline</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the active pipeline state. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_lite_f_x.html">LiteFX</a></li><li class="navelem"><a class="el" href="namespace_lite_f_x_1_1_rendering.html">Rendering</a></li><li class="navelem"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html">ICommandBuffer</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
