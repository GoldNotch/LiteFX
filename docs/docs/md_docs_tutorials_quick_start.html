<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LiteFX: Quick Start</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_xs.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LiteFX
   &#160;<span id="projectnumber">0.1.1.2021</span>
   </div>
   <div id="projectbrief">Computer Graphics Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_docs_tutorials_quick_start.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Quick Start </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This guide walks you through the steps required to write an application that renders a simple primitive. It demonstrates the most important features and use-cases of the <a class="el" href="namespace_lite_f_x.html">LiteFX</a> engine. Before you start, make sure you've successfully setup a project by following the <a href="md_docs_tutorials_project_setup.html">project setup guide</a>.</p>
<h1><a class="anchor" id="autotoc_md19"></a>
Defining an Application</h1>
<p>At the core of each <a class="el" href="namespace_lite_f_x.html">LiteFX</a> application lies the <code>Backend</code>. In theory, an application can provide different back-ends, however currently only one type of back-ends is implemented: the <code>RenderingBackend</code>. This back-end comes in two flavors: <code>VulkanBackend</code> and <code>DirectX12Backend</code>. For now, let's create a simple app, that uses the Vulkan backend and uses <a href="https://www.glfw.org/">GLFW</a> as a cross-platform window manager. In order to do this, we first need to extent the <em>CMakeLists.txt</em> file, created in the <a href="md_docs_tutorials_project_setup.html">project setup guide</a>. Add a <code>FIND_PACKAGE</code> command below the line where you are searching for <a class="el" href="namespace_lite_f_x.html">LiteFX</a>:</p>
<div class="fragment"><div class="line">FIND_PACKAGE(LiteFX 1.0 CONFIG REQUIRED)</div>
<div class="line">FIND_PACKAGE(glfw3 CONFIG REQUIRED)</div>
</div><!-- fragment --><p>In order to make GLFW available to your project, you have to also define the dependency using <code>TARGET_LINK_LIBRARIES</code>:</p>
<div class="fragment"><div class="line">TARGET_LINK_LIBRARIES(MyLiteFXApp PRIVATE LiteFX.Backends.Vulkan glfw)</div>
</div><!-- fragment --><p>Also - if you are not using <em>vcpkg</em> - you need to make sure, that the <em>glfw</em> shared library gets copied over to the build directory. To do this, extent the <code>FOREACH</code> loop at the bottom of your file:</p>
<div class="fragment"><div class="line">FOREACH(DEPENDENCY ${LITEFX_DEPENDENCIES} glfw)</div>
<div class="line">  # ...</div>
<div class="line">ENDFOREACH(DEPENDENCY ${LITEFX_DEPENDENCIES} glfw)</div>
</div><!-- fragment --><p>Re-configure your project and edit the <em>main.h</em> and <em>main.cpp</em> files and copy the following code to it:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;litefx/litefx.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;litefx/backends/vulkan.hpp&gt;</span>   <span class="comment">// Alternatively you can include dx12.hpp here.</span></div>
<div class="line"><span class="preprocessor">#include &lt;GLFW/glfw3.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;GLFW/glfw3native.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
</div><!-- fragment --><p>And to the <em>main.cpp</em> file:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;main.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespace_lite_f_x.html">LiteFX</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespace_lite_f_x_1_1_rendering.html">LiteFX::Rendering</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespace_lite_f_x_1_1_graphics.html">LiteFX::Graphics</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespace_lite_f_x_1_1_rendering_1_1_backends.html">LiteFX::Rendering::Backends</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>SimpleApp : <span class="keyword">public</span> <a class="code" href="class_lite_f_x_1_1_app.html">LiteFX::App</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="namespace_lite_f_x.html#a011c7594818b9883306e7b5465a4a602">String</a> getName() const noexcept<span class="keyword"> override </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;Simple App&quot;</span>; }</div>
<div class="line">    AppVersion getVersion() const noexcept<span class="keyword"> override </span>{ <span class="keywordflow">return</span> AppVersion(1, 0, 0, 0); }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    GLFWwindow* m_window;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    SimpleApp(GLFWwindow* window) : </div>
<div class="line">        App(), m_window(window)</div>
<div class="line">    {</div>
<div class="line">        this-&gt;initialize();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> initialize() <span class="keyword">override</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> run() <span class="keyword">override</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> resize(<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height) <span class="keyword">override</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> onResize(GLFWwindow* window, <span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> app = <span class="keyword">reinterpret_cast&lt;</span>SimpleApp*<span class="keyword">&gt;</span>(::glfwGetWindowUserPointer(window));</div>
<div class="line">    app-&gt;resize(width, height);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> SimpleApp::initialize()</div>
<div class="line">{</div>
<div class="line">    ::glfwSetWindowUserPointer(m_window, <span class="keyword">this</span>);</div>
<div class="line">    ::glfwSetFramebufferSizeCallback(m_window, ::onResize); </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> SimpleApp::run() </div>
<div class="line">{</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> SimpleApp::resize(<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height) </div>
<div class="line">{</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keyword">const</span> <span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span>** argv)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Create glfw window.</span></div>
<div class="line">    <span class="keywordflow">if</span> (!::glfwInit())</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Unable to initialize glfw.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    ::glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);</div>
<div class="line">    ::glfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE);</div>
<div class="line"> </div>
<div class="line">    GLFWwindow* window = ::glfwCreateWindow(800, 600, <span class="stringliteral">&quot;Simple App&quot;</span>, <span class="keyword">nullptr</span>, <span class="keyword">nullptr</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The next lines are Vulkan-specific:</span></div>
<div class="line">    <a class="code" href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">UInt32</a> extensions = 0;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>** extensionNames = ::glfwGetRequiredInstanceExtensions(&amp;extensions);</div>
<div class="line">    Array&lt;String&gt; requiredExtensions(extensions);</div>
<div class="line">    std::ranges::generate(requiredExtensions, [&amp;extensionNames, i = 0]() <span class="keyword">mutable</span> { <span class="keywordflow">return</span> <a class="code" href="namespace_lite_f_x.html#a011c7594818b9883306e7b5465a4a602">String</a>(extensionNames[i++]); });</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">        App::build&lt;SimpleApp&gt;(window)</div>
<div class="line">            .logTo&lt;ConsoleSink&gt;(LogLevel::Trace)</div>
<div class="line">            .useBackend&lt;VulkanBackend&gt;(requiredExtensions)                   <span class="comment">// Alternatively, you can use the DirectX12Backend here (and remove the required extensions).</span></div>
<div class="line">            .go();</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="namespace_lite_f_x.html#a0dde517531e4377f2f9e79477114c3f5">LiteFX::Exception</a>&amp; ex)</div>
<div class="line">    {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;An unhandled exception occurred: &quot;</span> &lt;&lt; ex.what() &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    ::glfwDestroyWindow(window);</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="ttc" id="aclass_lite_f_x_1_1_app_html"><div class="ttname"><a href="class_lite_f_x_1_1_app.html">LiteFX::App</a></div><div class="ttdef"><b>Definition:</b> app.hpp:17</div></div>
<div class="ttc" id="anamespace_lite_f_x_1_1_graphics_html"><div class="ttname"><a href="namespace_lite_f_x_1_1_graphics.html">LiteFX::Graphics</a></div><div class="ttdef"><b>Definition:</b> graphics.hpp:7</div></div>
<div class="ttc" id="anamespace_lite_f_x_1_1_math_html_a2c8d4a702fa98fc521a431084842b245"><div class="ttname"><a href="namespace_lite_f_x_1_1_math.html#a2c8d4a702fa98fc521a431084842b245">LiteFX::Math::UInt32</a></div><div class="ttdeci">uint32_t UInt32</div><div class="ttdef"><b>Definition:</b> math.hpp:37</div></div>
<div class="ttc" id="anamespace_lite_f_x_1_1_rendering_1_1_backends_html"><div class="ttname"><a href="namespace_lite_f_x_1_1_rendering_1_1_backends.html">LiteFX::Rendering::Backends</a></div><div class="ttdef"><b>Definition:</b> dx12.hpp:9</div></div>
<div class="ttc" id="anamespace_lite_f_x_1_1_rendering_html"><div class="ttname"><a href="namespace_lite_f_x_1_1_rendering.html">LiteFX::Rendering</a></div><div class="ttdef"><b>Definition:</b> dx12.hpp:9</div></div>
<div class="ttc" id="anamespace_lite_f_x_html"><div class="ttname"><a href="namespace_lite_f_x.html">LiteFX</a></div><div class="ttdef"><b>Definition:</b> app.hpp:6</div></div>
<div class="ttc" id="anamespace_lite_f_x_html_a011c7594818b9883306e7b5465a4a602"><div class="ttname"><a href="namespace_lite_f_x.html#a011c7594818b9883306e7b5465a4a602">LiteFX::String</a></div><div class="ttdeci">std::string String</div><div class="ttdef"><b>Definition:</b> string.hpp:10</div></div>
<div class="ttc" id="anamespace_lite_f_x_html_a0dde517531e4377f2f9e79477114c3f5"><div class="ttname"><a href="namespace_lite_f_x.html#a0dde517531e4377f2f9e79477114c3f5">LiteFX::Exception</a></div><div class="ttdeci">std::exception Exception</div><div class="ttdef"><b>Definition:</b> exceptions.hpp:12</div></div>
</div><!-- fragment --><p>Let's take a look at the code together. First, we create a window to paint on using <em>GLFW</em>. This is straightforward, but any other window manager can also be used. <a class="el" href="namespace_lite_f_x.html">LiteFX</a> does not make any restrictions on how the rendering surface is created. The only restriction is, that it needs to be compatible with the rendering back-end. However, since it is possible to also request a <code>HWND</code> handle from <em>GLFW</em> using <code>glfwGetWin32Window</code>, we can use <em>GLFW</em> it for both backends. The window pointer is passed to the <code>App::build&lt;SimpleApp&gt;()</code> call, which forwards the pointer to the <code>SimpleApp</code> constructor, where we store it.</p>
<p><b>Note on Vulkan</b>: for the Vulkan backend, it is important to specify the mandatory extensions that are required to create a valid surface. We do this by calling <code>glfwGetRequiredInstanceExtensions</code> and passing the result to the <code>VulkanBackend</code>. It is, however, possible to manually specify those extensions, if GLFW is not used. For Windows, those extensions are: <code>VK_KHR_surface</code> and <code>VK_KHR_win32_surface</code>.</p>
<p>We then specify a log target (which is completely optional) to be a console window. and tell the app to initialize a <code>VulkanBackend</code> for rendering. The <code>.go()</code> calls cause the builder to perform the actual object initialization and you will see it frequently when using the fluent API. However, using the fluent builder syntax is also optional - you could in fact create all the instances on your own. All classes follow an <a href="https://en.cppreference.com/w/cpp/language/raii">RAII</a> idiom, so it is clear from the constructors parameter, which objects are required to be initialized in which order.</p>
<p>Let's go on and take a look at the <code>SimpleApp</code> class. It implements the <code><a class="el" href="class_lite_f_x_1_1_app.html">LiteFX::App</a></code> base class, which is an abstract class, that requires us to provide some overrides, that implement the basic application control flow. Most notably, those are:</p>
<ul>
<li><code>initialize</code>, which is called by the <code><a class="el" href="class_lite_f_x_1_1_app.html">LiteFX::App</a></code> constructor.</li>
<li><code>run</code>, which is called by the <code>AppBuilder</code>, after the app has been initialized. Note that, if you prefer not using the fluent builder syntax, you would have to call it on your own.</li>
<li><code>resize</code>, which is called if an resize event occurs.</li>
</ul>
<p>Since the app itself is agnostic towards the actual window manager, we have to manually invoke the resize event. We do this by storing the application instance pointer using <code>glfwSetWindowUserPointer</code> and calling the <code>resize</code> method within the <em>GLFW</em> framebuffer resize event callback.</p>
<h2><a class="anchor" id="autotoc_md25"></a>
Running the Application</h2>
<p>The app model automatically calls <code><a class="el" href="class_sample_app.html#adc39ee28484dbbe9586324b49b506d62">SampleApp::run</a></code> as soon as the app is ready. This method is the main method, that should implement the game loop. If it returns, the application will close. In its most simple form, the method can be implemented like this:</p>
<div class="fragment"><div class="line"><span class="comment">// TODO: initialize.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Run application loop until the window is closed.</span></div>
<div class="line"><span class="keywordflow">while</span> (!::glfwWindowShouldClose(m_window))</div>
<div class="line">{</div>
<div class="line">    ::glfwPollEvents();</div>
<div class="line">    <span class="comment">// TODO: draw frame.</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// TODO: cleanup.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Destroy the window.</span></div>
<div class="line">::glfwDestroyWindow(m_window);</div>
<div class="line">::glfwTerminate();</div>
</div><!-- fragment --><p>There are three to-dos here:</p>
<ol type="1">
<li>Initialization, includes creating a device, setting up the render passes and pipelines and creating buffers and descriptors.</li>
<li>Rendering, which repeatedly draws a frame to a back buffer.</li>
<li>Cleanup, which means releasing all resources before destroying the device and quitting the app.</li>
</ol>
<p>In the following, we will take a closer look into each of the steps.</p>
<h3><a class="anchor" id="autotoc_md26"></a>
Creating a Device</h3>
<p>Before we can do any rendering, we need to create a device. A device is the central instance for each GPU job. Conceptually it represents the hardware interface for the application. It does, however, not represent the actual hardware itself - that's the purpose of <em>Adapters</em>. There can be multiple devices for an adapter and there can be devices that make use of different adapters. For our example, we use the default adapter, which is typically the main GPU. To request the default adapter, we pass <code>std::nullopt</code> to the <code>findAdapter</code> method of the rendering backend of our app.</p>
<p>The next thing we need is a surface, which is a way of telling the device where to render to. The way surfaces are created slightly differs between DirectX 12 and Vulkan. For DirectX 12 a surface is nothing more than a <code>HWND</code>. For Vulkan, however, we need to create a surface and we can use <em>GLFW</em> for it.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> backend = this-&gt;findBackend&lt;VulkanBackend&gt;(BackendType::Rendering);</div>
<div class="line"><span class="keyword">auto</span> adapter = backend-&gt;findAdapter(std::nullopt);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// For Vulkan:</span></div>
<div class="line"><span class="keyword">auto</span> surface = backend-&gt;createSurface([<span class="keyword">this</span>](<span class="keyword">const</span> VkInstance&amp; instance) {</div>
<div class="line">    VkSurfaceKHR surface;</div>
<div class="line">    raiseIfFailed&lt;RuntimeException&gt;(::glfwCreateWindowSurface(instance, m_window, <span class="keyword">nullptr</span>, &amp;surface), <span class="stringliteral">&quot;Unable to create GLFW window surface.&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> surface;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// For DX12:</span></div>
<div class="line"><span class="keyword">auto</span> surface = makeUnique&lt;DirectX12Surface&gt;(::glfwGetWin32Window(m_window));</div>
</div><!-- fragment --><p>With the surface and adapter, we can now proceed to creating our device. Creating a device automatically initializes the <em>Swap Chain</em>, which we will talk about in detail later. We can simply create it with a default extent, but it is more efficient to directly tell the swap chain how large the surface is from the beginning. This way, we prevent it from beeing re-created after the window first gets drawn to. In order to do this, we can request the frame buffer size from <em>GLFW</em>. Note that the frame buffer size is not always equal to the window size, depending on the monitor. High DPI monitors use a more coarse window coordinate system. You can read about it in more detail <a href="https://www.glfw.org/docs/3.3/group__window.html#ga0e2637a4161afb283f5300c7f94785c9">here</a>.</p>
<p>With the adapter, surface and frame buffer extent, we can go ahead to create our device. We also specify the output format (<code>Format::B8G8R8A8_SRGB</code>) and the number of frames, which we concurrently want to draw. This is commonly referred to as <em>frames in flight</em>, or <em>back buffers</em> throughout the engine, though there is a slight difference. Back buffers refer to the number of frame buffers in the swap chain, whilst frames in flight is a broader concept, that for example influences how many buffers or descriptor sets you want to allocate later.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> width, height;</div>
<div class="line">::glfwGetFramebufferSize(m_window, &amp;width, &amp;height);</div>
<div class="line">m_device = backend-&gt;createDevice(*adapter, *surface, Format::B8G8R8A8_SRGB, Size2d(width, height), 3);</div>
</div><!-- fragment --><p>We store the device in a variable <code>m_device</code>, which we define as a member variable of <code><a class="el" href="class_sample_app.html">SampleApp</a></code>, since we are going to make heavy use of it throughout the whole application.</p>
<div class="fragment"><div class="line">UniquePtr&lt;VulkanDevice&gt; m_device;   <span class="comment">// or UniquePtr&lt;DirectX12Device&gt;</span></div>
</div><!-- fragment --><p>Note how the <code>createDevice</code> method returns a <code>UniquePtr</code>. Receiving a unique pointer from any call transfers ownership to your application. This means, that from now on, you are responsible for managing the device lifetime and make sure that it gets released properly. We will do this later, when we talk about cleaning up. From now on, all member variables that should be stored are marked with the <code>m_</code> prefix and their declaration will not be explicitly mentioned, as long as it does only involve declaring a simple pointer or reference.</p>
<h3><a class="anchor" id="autotoc_md27"></a>
Creating a Render Pass</h3>
<p>Each frame is drawn by at least one render pass. A render pass is a timeline entity of each frame. There can only be one render pass active at one time. Render passes, like everything in modern graphics APIs are executed asynchronously, though. Each call that you do on a render pass records a command to be executed, if the GPU allocates a time slot for it. By itself, the render pass does not store much information and is more an entity that is used to describe the flow of images through the render process of a frame. This is called <em>Render Graph</em>. A render graph is described by a set of inter-dependend render passes.</p>
<p>Note that <a class="el" href="namespace_lite_f_x.html">LiteFX</a> does not automatically build the render graph for you. Instead you are responsible to begin and end each render pass manually, as well as map the input attachments to a render pass. It does, however, provide you with two tools to model the image flow: <em>Render Targets</em> and <em>Input Attachment Mappings</em>. Render targets describe the output of a render pass. Input attachment mappings do the exact opposite and tell a render pass to use the render target of another render pass as an input. This way, there's an implicit relationship between render passes. You have to end a render pass before you can use its render targets as input attachments for another render pass.</p>
<p>In our example, however, we do not use multiple render passes and instead only create one render pass, that directly draws to our surface. We do this by defining a render pass with one render target, that has the <code>Present</code> type. This type is special in a way, that there can only be one present target throughout all render passes. The present target is whats written to the front buffer if a swap chain is swapped. Present targets can also not be used as input attachments. Other render target types are <code>Color</code>, which can store arbitrary data and <code>DepthStencil</code>, which can only exist once per render pass and stores depth, stencil or depth and stencil data.</p>
<p>The other values that are provided to a render target are:</p>
<ul>
<li>The render target format, which in our example is dictated by the swap chain format we've chosen earlier.</li>
<li>The multisampling level, which we set to <code>x1</code>, since we do not yet want to use multi sampling.</li>
<li>A clear value vector, which contains the values that the render target will be cleared with when starting the render pass. For our <em>BGRA</em> image, we want to clear it with black and an alpha value of <code>0.0</code>.</li>
<li>A boolean switch to enable or disable clearing the values, which we set to true, since we want to clear our image with the clear values specified earlier.</li>
<li>A boolean switch to enable clearing for stencil buffers. This switch is only used, if the render target is a <code>DepthStencil</code> target and the format supports stencil values. It can be used to disable clearing stencil values and only clear depth values for depth/stencil targets.</li>
<li>A boolean switch that states, if we want to preserve the contents of the image after the render pass has finished. Since we do not want to use our render target as input attachment for another render pass, we also set this value to <code>false</code>.</li>
</ul>
<div class="fragment"><div class="line">m_renderPass = m_device-&gt;buildRenderPass()</div>
<div class="line">    .renderTarget(RenderTargetType::Present, Format::B8G8R8A8_SRGB, MultiSamplingLevel::x1, { 0.f, 0.f, 0.f, 0.f }, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>)</div>
<div class="line">    .go();</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md28"></a>
Creating a Render Pipeline</h3>
<p>Next on our list is creating the render pipeline. The singular here is important, because in most applications you will have many pipelines created from one render pass. A pipeline contains the whole state that is used to render a buffer. It tells the GPU how to interpret inputs, how to store the outputs and which shader programs to use. More importantly, it tells the GPU about the shader program parameters and how they are layed out. A pipeline itself is a state object, that can be bound to a render pass. There can only be one pipeline active at a time and since there can also be only one render pass active at a time, there's only one active pipeline at each point in the drawing timeline. Changing the pipeline state may be an expensive operation and you should not do this frequently. Instead, group together objects that can be rendered with the same pipeline and draw all of them before switching to another pipeline.</p>
<p>The first important states, a pipeline stores are the <em>Viewport</em> and <em>Scissor</em> states. Both tell the GPU which pixels to draw to the output render area, however a scissor does not imply a viewport transform (that is a scaling of the image to fit the viewport). For our example, we set both (the viewport and the scissor) to the whole size of our frame buffer. Note that it is possible to have multiple viewports and scissors. In order to do this, we use the <code>width</code> and <code>height</code> we've requested earlier.</p>
<p>Furthermore, each pipeline can be assigned an ID, which must be unique for the render pass and a name, which is soley used for debugging purposes. Let's start by creating our viewport and scissor and then continue with building our pipeline state.</p>
<div class="fragment"><div class="line">m_viewport = makeShared&lt;Viewport&gt;(RectF(0.f, 0.f, <span class="keyword">static_cast&lt;</span><a class="code" href="namespace_lite_f_x_1_1_math.html#a5f0e08243809f53dff6b21d29e8a6f75">Float</a><span class="keyword">&gt;</span>(width), <span class="keyword">static_cast&lt;</span><a class="code" href="namespace_lite_f_x_1_1_math.html#a5f0e08243809f53dff6b21d29e8a6f75">Float</a><span class="keyword">&gt;</span>(height)));</div>
<div class="line">m_scissor = makeShared&lt;Scissor&gt;(RectF(0.f, 0.f, <span class="keyword">static_cast&lt;</span><a class="code" href="namespace_lite_f_x_1_1_math.html#a5f0e08243809f53dff6b21d29e8a6f75">Float</a><span class="keyword">&gt;</span>(width), <span class="keyword">static_cast&lt;</span><a class="code" href="namespace_lite_f_x_1_1_math.html#a5f0e08243809f53dff6b21d29e8a6f75">Float</a><span class="keyword">&gt;</span>(height)));</div>
<div class="line"> </div>
<div class="line">m_pipeline = m_renderPass-&gt;makePipeline(0, <span class="stringliteral">&quot;Basic Pipeline&quot;</span>)</div>
<div class="line">    .withViewport(m_viewport)</div>
<div class="line">    .withScissor(m_scissor)</div>
<div class="ttc" id="anamespace_lite_f_x_1_1_math_html_a5f0e08243809f53dff6b21d29e8a6f75"><div class="ttname"><a href="namespace_lite_f_x_1_1_math.html#a5f0e08243809f53dff6b21d29e8a6f75">LiteFX::Math::Float</a></div><div class="ttdeci">float_t Float</div><div class="ttdef"><b>Definition:</b> math.hpp:40</div></div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md29"></a>
Input Assembler State</h4>
<p>Next we tell our pipeline how to handle geometry inputs. Geometry is described by vertices and indices. A geometry has a certain topology, which is described by the <code>PrimitiveTopology</code> enumeration. Our geometry is represented as a list of triangles, so we set it to <code>TriangleList</code>. Since our geometry vertices must not be ordered, we use an index buffer to tell which vertices to use for triangle rendering. We set the index type to <code>UInt16</code>, which has enough space for <code>65535</code> vertices and is enough for our example.</p>
<p>Finally, we define out vertex buffer layout. This means, that we tell the input assembler state about the memory layout of a single vertex. We use the <code>Vertex</code> object, defined in the <code><a class="el" href="namespace_lite_f_x_1_1_graphics.html">LiteFX::Graphics</a></code> namespace, but it is possible to use a custom structure, too. Each property is of the vertex is mapped to an attribute, which describes the memory layout of the property and where to find it within the buffer. Furthermore, it tells the renderer, where the attribute should be bound to. For example, the <code>Position</code> property of the vertex object is a 3-component 32-bit float vector, so its format is <code>XYZ32F</code>. In the shader, the position is the first element of the vertex, so we set its location to <code>0</code>.</p>
<div class="fragment"><div class="line">.inputAssembler()</div>
<div class="line">    .withTopology(PrimitiveTopology::TriangleList)</div>
<div class="line">    .withIndexType(IndexType::UInt16)</div>
<div class="line">    .addVertexBuffer(<span class="keyword">sizeof</span>(Vertex), 0)</div>
<div class="line">        .addAttribute(0, BufferFormat::XYZ32F, offsetof(Vertex, Position))</div>
<div class="line">        .addAttribute(1, BufferFormat::XYZW32F, offsetof(Vertex, Color))</div>
<div class="line">        .go()</div>
<div class="line">    .go()</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md30"></a>
Rasterizer State</h4>
<p>Next, we tell the pipeline about how those primitives (i.e. triangles in our example) should be drawn. We want to draw solid faces, so we set the <code>PolygonMode</code> to <code>Solid</code>. Another property of the rasterizer state is the face culling state. First, we set the order of vertices, which dictates which side of the primitive is interpreted as <em>front</em> and which one is the <em>back</em>. We set the <code>CullOrder</code> to <code>ClockWise</code> to tell the pipeline to treat this ordering as <em>front face</em>. Finally, we tell the pipeline to draw both sides of a polygon, by setting the <code>CullMode</code> to <code>Disabled</code>.</p>
<div class="fragment"><div class="line">.rasterizer()</div>
<div class="line">    .withPolygonMode(PolygonMode::Solid)</div>
<div class="line">    .withCullOrder(CullOrder::ClockWise)</div>
<div class="line">    .withCullMode(CullMode::Disabled)</div>
<div class="line">    .go()</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md31"></a>
Render Pipeline Layout</h4>
<p>Each pipeline is defined using a <em>Pipeline Layout</em>. The layout stores meta-data about the pipeline state. This includes the shader program to use and the how the buffers are addressed by this shader. We start by defining the shader program, which in our simple example should contain two stages: <em>Vertex</em> and <em>Fragment</em> shaders (those are also called <em>Pixel</em> shaders in DirectX). A program is built from multiple modules, where each module type may only exist once within a program. The modules are loaded from files and must be in a compatible binary format. For Vulkan this format is <em>SPIR-V</em>, for DirectX it's <em>DXIL</em>. We define those shaders later, for now it is only important that they are written to the <em>shaders</em> directory and called <em>vs.spv</em> (vertex shader) and <em>fs.spv</em> (fragment shader).</p>
<div class="fragment"><div class="line">.layout()</div>
<div class="line">    .shaderProgram()</div>
<div class="line">        .addVertexShaderModule(<span class="stringliteral">&quot;shaders/vs.spv&quot;</span>)        <span class="comment">// .dxi for DXIL</span></div>
<div class="line">        .addFragmentShaderModule(<span class="stringliteral">&quot;shaders/fs.spv&quot;</span>)</div>
<div class="line">        .go()</div>
</div><!-- fragment --><p>Finally we need to tell the pipeline layout about the buffers that are used by the shader. Buffers are grouped into descriptor sets. Each descriptor set can contain multiple buffers and is visible to a pre-defined range of shader stages. Each buffer is bound to a certain location within the descriptor set. It is a good pracitce to group buffers into descriptor sets, based on update frequency. We have two buffers in our example, that are updated in different frequencies:</p>
<ul>
<li>The <code><a class="el" href="struct_camera_buffer.html">CameraBuffer</a></code>, which is only updated when the viewport changes (our example camera is static). The camera buffer will be bound to location <code>0</code> of set <code>0</code> and will be visible to the vertex and fragment shader stages.</li>
<li>The <code><a class="el" href="struct_transform_buffer.html">TransformBuffer</a></code>, which is updated every frame (we want to draw a rotating rectangle). The transform buffer will be bound to location <code>0</code> of set <code>1</code> and will only be visible to the vertex shader.</li>
</ul>
<p>For now, we will only define the descriptor sets and take a look at the <code><a class="el" href="struct_camera_buffer.html">CameraBuffer</a></code> and <code><a class="el" href="struct_transform_buffer.html">TransformBuffer</a></code> objects later.</p>
<div class="fragment"><div class="line">    .addDescriptorSet(0, ShaderStage::Vertex | ShaderStage::Fragment)</div>
<div class="line">        .addUniform(0, <span class="keyword">sizeof</span>(<a class="code" href="struct_camera_buffer.html">CameraBuffer</a>))</div>
<div class="line">        .go()</div>
<div class="line">    .addDescriptorSet(1, ShaderStage::Vertex)</div>
<div class="line">        .addUniform(0, <span class="keyword">sizeof</span>(<a class="code" href="struct_transform_buffer.html">TransformBuffer</a>))</div>
<div class="line">        .go()</div>
<div class="line">    .go()   <span class="comment">// Build pipeline layout.</span></div>
<div class="line">.go();  <span class="comment">// Build render pipeline.</span></div>
<div class="ttc" id="astruct_camera_buffer_html"><div class="ttname"><a href="struct_camera_buffer.html">CameraBuffer</a></div><div class="ttdef"><b>Definition:</b> sample.cpp:25</div></div>
<div class="ttc" id="astruct_transform_buffer_html"><div class="ttname"><a href="struct_transform_buffer.html">TransformBuffer</a></div><div class="ttdef"><b>Definition:</b> sample.cpp:29</div></div>
</div><!-- fragment --><p>For more details about buffers and descriptor sets, kindly refer to the <a href="https://github.com/crud89/LiteFX/wiki/Resource-Bindings">project wiki</a> or read the API documentation about descriptor sets.</p>
<h5>Defining and Building Shader Modules</h5>
<p>We already told the pipeline to load the vertex and fragment shaders, however, we do not yet have defined them. Create two new files in the project directory: <em>vs.hlsl</em> for the vertex shader and <em>fs.hlsl</em> for the fragment shader. First, let's take a look at the vertex shader:</p>
<div class="fragment"><div class="line">#pragma pack_matrix(row_major)</div>
<div class="line"> </div>
<div class="line">struct VertexInput</div>
<div class="line">{</div>
<div class="line">    float3 Position : POSITION;</div>
<div class="line">    float4 Color : COLOR;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">struct VertexData </div>
<div class="line">{</div>
<div class="line">    float4 Position : SV_POSITION;</div>
<div class="line">    float4 Color : COLOR;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">struct CameraData</div>
<div class="line">{</div>
<div class="line">    float4x4 ViewProjection;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">struct TransformData</div>
<div class="line">{</div>
<div class="line">    float4x4 Model;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">ConstantBuffer&lt;CameraData&gt;    camera    : register(b0, space0);</div>
<div class="line">ConstantBuffer&lt;TransformData&gt; transform : register(b0, space1);</div>
<div class="line"> </div>
<div class="line">VertexData main(in VertexInput input)</div>
<div class="line">{</div>
<div class="line">    VertexData vertex;</div>
<div class="line">    </div>
<div class="line">    float4 position = mul(float4(input.Position, 1.0), transform.Model);</div>
<div class="line">    vertex.Position = mul(position, camera.ViewProjection);</div>
<div class="line">    </div>
<div class="line">    vertex.Color = input.Color;</div>
<div class="line"> </div>
<div class="line">    return vertex;</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>VertexInput</code> corresponds to the definition we earlier passed to the input assembler. <code>VertexData</code> describes the output vertex of the vertex shader. The two constant buffers correspond to the descriptors we passed to the descriptor sets in the pipeline definition. Note how the descriptor set ID maps to the <code>space</code> in the shader. The main function is pretty straightforward, as it only performs the view/projection transform for the vertex and copies its color. Also note the <code>#pragma pack_matrix(row_major)</code>: since we are going to use GLM in this tutorial and GLM produces row-major matrices, this is important. If you are using another math library, you can simply change this line accordingly.</p>
<p>The fragment shader is also pretty rudimentary for the moment:</p>
<div class="fragment"><div class="line">#pragma pack_matrix(row_major)</div>
<div class="line"> </div>
<div class="line">struct VertexData </div>
<div class="line">{</div>
<div class="line">    float4 Position : SV_POSITION;</div>
<div class="line">    float4 Color : COLOR;</div>
<div class="line">}; </div>
<div class="line"> </div>
<div class="line">struct FragmentData</div>
<div class="line">{</div>
<div class="line">    float4 Color : SV_TARGET0;</div>
<div class="line">    float Depth : SV_DEPTH;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">FragmentData main(VertexData input)</div>
<div class="line">{</div>
<div class="line">    FragmentData fragment;</div>
<div class="line">    </div>
<div class="line">    fragment.Depth = input.Position.z;</div>
<div class="line">    fragment.Color = input.Color;</div>
<div class="line"> </div>
<div class="line">    return fragment;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Again, the <code>VertexData</code> contains the data we are passing from the vertex to the fragment shader stage. <code>FragmentData</code> holds the information about the fragment, where the <code>Color</code> property maps to the first render target and the <code>Depth</code> property maps to the depth/stencil target we defined earlier in the rasterizer state. The does not do any further computations, but copies the values from the vertex input.</p>
<p>Usually you have to manually compile the shaders before you can use them. <a class="el" href="namespace_lite_f_x.html">LiteFX</a> is capable to do this for you automatically and provides two helpers for CMake projects: <code>ADD_SHADER_MODULE</code> and <code>TARGET_LINK_SHADERS</code>. Let's head over to our <em>CMakeLists.txt</em> file and add the following lines below the <code>TARGET_LINK_LIBRARIES</code>:</p>
<div class="fragment"><div class="line">ADD_SHADER_MODULE(MyVertexShader SOURCE &quot;vs.hlsl&quot; LANGUAGE HLSL TYPE VERTEX COMPILE_AS SPIRV SHADER_MODEL 6_3 COMPILER DXC)</div>
<div class="line">ADD_SHADER_MODULE(MyFragmentShader SOURCE &quot;fs.hlsl&quot; LANGUAGE HLSL TYPE FRAGMENT COMPILE_AS SPIRV SHADER_MODEL 6_3 COMPILER DXC)</div>
<div class="line">TARGET_LINK_SHADERS(MyLiteFXApp SHADERS MyVertexShader MyFragmentShader)</div>
</div><!-- fragment --><p>First, we define two targets <code>MyVertexShader</code> and <code>MyFragmentShader</code>, one for each shader module. The options behind specify the language, shader type, intermediate language (<code>SPIRV</code> for Vulkan, change it to <code>DXIL</code> for DirectX 12), the shader model and the compiler to use. <code>DXC</code> is recommended, unless you want to compile <em>GLSL</em> shaders, which can only be compiled using <code>GLSLC</code>. Note, however, that you cannot use GLSL shaders to target DirectX 12.</p>
<p>The shader helper attempts to find the <em>GLSLC</em> and <em>DXC</em> compilers automatically. If you have the Vulkan SDK installed, it looks for the compilers there. It prefers the Vulkan SDK, since this DXC distribution supports SPIR-V code generation and GLSLC is present too. If you only plan on using the DirectX 12 backend and don't have the Vulkan SDK installed, the helper falls back to the DXC distribution, installed with the Windows 10 SDK. Note, however, that this distribution does not support SPIR-V code generation. It is possible, however, to specify a custom location for each compiler, by setting the <code>BUILD_DXC_COMPILER</code> and/or <code>BUILD_GLSLC_COMPILER</code> variables.</p>
<p>Using <code>TARGET_LINK_SHADERS</code> we setup a dependency for between the shaders and our application, so that the shaders are copied to the build directory properly. Note that by default, the shaders are copied into a <code>shaders/</code> subdirectory. You can change this subdirectory by changing the <code>SHADER_DEFAULT_SUBDIR</code> variable. Keep in mind to also update the pipeline state definition, if you do change the directory.</p>
<p>For more information on how to use the helpers, refer to the <a href="https://github.com/crud89/LiteFX/wiki/Shader-Module-Targets">project wiki</a>.</p>
<h2><a class="anchor" id="autotoc_md32"></a>
Creating and Managing Buffers</h2>
<p>Next, we need to pass data to the GPU for it to process. <a class="el" href="namespace_lite_f_x.html">LiteFX</a> supports different data management strategies, that you can choose from:</p>
<ul>
<li>Write once/Read once: This strategy is most common for buffers that are changing with each frame.</li>
<li>Write once/Read multiple: This strategy requires you to create two buffers: one on the CPU and one on the GPU and issue a transfer between both. This is most efficient for static buffers and textures.</li>
</ul>
<p>Other scenarios are also possible, however, they are all implemented using the techniques demonstrated by those two (and most common) scenarios.</p>
<h3><a class="anchor" id="autotoc_md33"></a>
Vertex- and Index Buffers</h3>
<p>Vertex and index buffers are two examples of data, that is typically written once and read multiple times. We thus create a CPU-visible staging buffer for both, write the required data to it and transfer it to a GPU-visible resource. But first, let's define a vertex and index buffer structure:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> Array&lt;Vertex&gt; vertices =</div>
<div class="line">{</div>
<div class="line">    { { 0.0f, 0.0f, 0.5f }, { 1.0f, 0.0f, 0.0f, 1.0f }, { 0.0f, 0.0f } },</div>
<div class="line">    { { 0.5f, 0.0f, -0.5f }, { 0.0f, 1.0f, 0.0f, 1.0f }, { 0.0f, 0.0f } },</div>
<div class="line">    { { -0.5f, 0.0f, -0.5f }, { 0.0f, 0.0f, 1.0f, 1.0f }, { 0.0f, 0.0f } },</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> Array&lt;UInt16&gt; indices = { 0, 1, 2 };</div>
</div><!-- fragment --><p>We define a vertex buffer with three vertices, each with a different color. The last two values represent the texture coordinate, which we do not want to use yet. It is totally possible to use a custom <code>Vertex</code> object. Just keep in mind to change the input assembler state accordingly. We specify the index buffer to form a triangle from all three vertices. The order of the indices is specified by the <code>CullOrder</code> we defined in the rasterizer state.</p>
<p>Next, let's transfer the buffers to the GPU. We start of by storing the input assembler reference (for easier access) and creating a command buffer to record all transfer commands. We do this right below the pipeline creation code:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> inputAssembler = m_pipeline-&gt;inputAssembler();</div>
<div class="line"><span class="keyword">auto</span> commandBuffer = m_device-&gt;bufferQueue().createCommandBuffer(<span class="keyword">true</span>);</div>
</div><!-- fragment --><p>We then create a CPU visible vertex buffer and copy the vertex data into it:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> stagedVertices = m_device-&gt;factory().createVertexBuffer(inputAssembler-&gt;vertexBufferLayout(0), BufferUsage::Staging, vertices.size());</div>
<div class="line">stagedVertices-&gt;map(vertices.data(), vertices.size() * <span class="keyword">sizeof</span>(::Vertex), 0);</div>
</div><!-- fragment --><p>The <code>BufferUsage</code> defines where the buffer should be visible from. <code>Staging</code> corresponds to a CPU-only visible buffer, whilst <code>Resource</code> is used for GPU-only visible buffers. We will use another buffer type (<code>Dynamic</code>) later to represent <em>Write once/Read once</em> scenarios. Finally, we copy the data to the vertex buffer by calling <code>map</code>. After this, we can create the GPU-visible vertex buffer and issue a transfer command:</p>
<div class="fragment"><div class="line">m_vertexBuffer = m_device-&gt;factory().createVertexBuffer(inputAssembler-&gt;vertexBufferLayout(0), BufferUsage::Resource, vertices.size());</div>
<div class="line">m_vertexBuffer-&gt;transferFrom(*commandBuffer, *stagedVertices, 0, 0, vertices.size());</div>
</div><!-- fragment --><p>We store the vertex buffer in a member variable. We then go ahead and repeat the same process for the index buffer:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> stagedIndices = m_device-&gt;factory().createIndexBuffer(inputAssembler-&gt;indexBufferLayout(), BufferUsage::Staging, indices.size());</div>
<div class="line">stagedIndices-&gt;map(indices.data(), indices.size() * inputAssembler-&gt;indexBufferLayout().elementSize(), 0);</div>
<div class="line"> </div>
<div class="line">m_indexBuffer = m_device-&gt;factory().createIndexBuffer(inputAssembler-&gt;indexBufferLayout(), BufferUsage::Resource, indices.size());</div>
<div class="line">m_indexBuffer-&gt;transferFrom(*commandBuffer, *stagedIndices, 0, 0, indices.size());</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md34"></a>
Constant/Uniform Buffers</h3>
<p>The same memory management concepts as for vertex and index buffers apply to shader resources (i.e. constant buffers, samplers or textures). However, they have one more aspect to them: <em>descriptors</em>. Descriptors are basically GPU-pointers in a sense, that they point to a GPU-visible resource before a draw call is issued. They must, however, not change until the draw call has finished (i.e. the end of the frame). Managing descriptors manually can be quite challenging. Luckily, <a class="el" href="namespace_lite_f_x.html">LiteFX</a> already implements flexible descriptor management strategies and the way you interact with descriptors is always the same when using <a class="el" href="namespace_lite_f_x.html">LiteFX</a>.</p>
<p>Descriptors are grouped into <em>Descriptor Sets</em>. We already defined two descriptor sets when setting up our pipeline. For now, both are only contain one descriptor, a uniform buffer each. You can add as many descriptors to a set as you like, there are some things to keep in mind, though. Firstly, you must not mix samplers and images in one descriptor set. This rule is not directly enforced by the Vulkan backend, however it's a strong requirement for the DirectX 12 backend, so you should follow it anyway to keep your pipeline definitions consistent. Secondly, you should define descriptor sets based on the frequency they are updated. This is a good practice and generally helps to organize GPU workload.</p>
<p>Descriptor sets directly map to a GPU <code>space</code>. Within this space, a descriptor has a <code>binding</code>, which defines from which register the descriptor gets accessed by the shader. We defined both in the pipeline layout, as well as the shader code. Feel free to go back to those sections to ensure that you understood how descriptors are mapped to the shader. If you think you understood the relationship, go ahead with the next sections.</p>
<h4><a class="anchor" id="autotoc_md35"></a>
Static Buffers</h4>
<p>We will first map a static <code><a class="el" href="struct_camera_buffer.html">CameraBuffer</a></code> to the shader. This buffer contains the camera View/Projection matrix. In our example, the camera cannot move, making it a perfect fit for static buffers. As mentioned earlier, static buffers correspond to the <em>Write once/Read multiple</em> strategy and should be transferred to a GPU-visible resource. We will thus create two buffers, as we did for the vertices and indices again and issue a transfer command to copy the data to the GPU. We will then allocate a descriptor set and update it accordingly, so that the descriptor points to the GPU camera buffer.</p>
<p>Let's start off by defining our camera buffer structure:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="struct_camera_buffer.html">CameraBuffer</a> {</div>
<div class="line">    glm::mat4 <a class="code" href="struct_camera_buffer.html#a1b25393a92e2ce03ec2b51f5b5b18cdf">ViewProjection</a>;</div>
<div class="line">} camera;</div>
<div class="ttc" id="astruct_camera_buffer_html_a1b25393a92e2ce03ec2b51f5b5b18cdf"><div class="ttname"><a href="struct_camera_buffer.html#a1b25393a92e2ce03ec2b51f5b5b18cdf">CameraBuffer::ViewProjection</a></div><div class="ttdeci">glm::mat4 ViewProjection</div><div class="ttdef"><b>Definition:</b> sample.cpp:26</div></div>
</div><!-- fragment --><p>Note that we are using <em>glm</em> to store the matrix here, but you can use any other representation that suits you. Keep in mind to specify the matrix order (<code>#pragma pack_matrix</code>) in the shader sources, if it is different to our example. If you want to follow this guide, you need to add an include for glm matrix transformations:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;glm/gtc/matrix_transform.hpp&gt;</span></div>
</div><!-- fragment --><p>Next, we create the two buffers that should store the camera data:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span>&amp; cameraBindingLayout = m_pipeline-&gt;layout().layout(0);</div>
<div class="line">m_cameraStagingBuffer = m_device-&gt;factory().createConstantBuffer(cameraBindingLayout.layout(0), BufferUsage::Staging, 1);</div>
<div class="line">m_cameraBuffer = m_device-&gt;factory().createConstantBuffer(cameraBindingLayout.layout(0), BufferUsage::Resource, 1);</div>
</div><!-- fragment --><p>First, we request a reference of the descriptor set layout (at space <em>0</em>), that contains the camera buffer descriptor. We then create two constant buffers for the descriptor bound to register <em>0</em> of the descriptor set. We store both buffers in a member variable, since we want to be able to update the camera buffer later (for example, if a resize-event occurs). The camera buffer is still static, since such events occur infrequently.</p>
<p>Let's move on and compute the view and projection matrix and pre-multiply them together:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> aspectRatio = m_viewport-&gt;getRectangle().width() / m_viewport-&gt;getRectangle().height();</div>
<div class="line">glm::mat4 view = glm::lookAt(glm::vec3(1.5f, 1.5f, 1.5f), glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(0.0f, 0.0f, 1.0f));</div>
<div class="line">glm::mat4 projection = glm::perspective(glm::radians(60.0f), aspectRatio, 0.0001f, 1000.0f);</div>
<div class="line">projection[1][1] *= -1.f;   <span class="comment">// Fix GLM clip coordinate scaling.</span></div>
<div class="line">camera.<a class="code" href="struct_camera_buffer.html#a1b25393a92e2ce03ec2b51f5b5b18cdf">ViewProjection</a> = projection * view;</div>
</div><!-- fragment --><p>It is important to fix the GLM clip coordinate scaling in the projection matrix. Since GLM has originally been developed for OpenGL, the y-coordinate of the camera space is inverted. The easiest way to fix this, is to pre-apply a flip transform by inverting the Y-coordinate. If you leave out this line, you image might end up beeing rendered upside-down in Vulkan.</p>
<p>In the last line, we pre-multiply the view/projection matrix and store it in the camera buffer, which we can now transfer to the GPU:</p>
<div class="fragment"><div class="line">m_cameraStagingBuffer-&gt;map(<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(&amp;camera), <span class="keyword">sizeof</span>(camera));</div>
<div class="line">m_cameraBuffer-&gt;transferFrom(*commandBuffer, *m_cameraStagingBuffer);</div>
</div><!-- fragment --><p>The last thing we need to do is making the descriptor point to the GPU-visible camera buffer. We only need to do this once, since we do not change the buffer location on the GPU:</p>
<div class="fragment"><div class="line">m_cameraBindings = cameraBindingLayout.allocate();</div>
<div class="line">m_cameraBindings-&gt;update(*m_cameraBuffer, 0);</div>
</div><!-- fragment --><p>Here we first allocate a descriptor set that holds our descriptor for the camera buffer. We then update the descriptor bound to register <em>0</em> to point to the GPU-visible camera buffer. Finally, with all the transfer commands being recorded to the command buffer, we can submit the buffer and wait for it to be executed:</p>
<div class="fragment"><div class="line">commandBuffer-&gt;end(<span class="keyword">true</span>, <span class="keyword">true</span>);</div>
<div class="line">commandBuffer = <span class="keyword">nullptr</span>;</div>
<div class="line">stagedVertices = <span class="keyword">nullptr</span>;</div>
<div class="line">stagedIndices = <span class="keyword">nullptr</span>;</div>
</div><!-- fragment --><p>We also explicitly release the temporary staging buffers and the transfer command buffer here, since we do not need them anymore and we need to ensure that they are released before we close the application.</p>
<h4><a class="anchor" id="autotoc_md36"></a>
Dynamic Buffers</h4>
<p>We now want to look at a different memory management strategy: <em>Write once/Read once</em>. For resources that change frequently (i.e. every frame), this strategy is more efficient than record transfer commands and waiting for the transfer to happen. Instead we rely on the graphics queue to ensure that our buffer is transferred automatically, when it is needed.</p>
<p>Let's begin with defining our transform buffer structure:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="struct_transform_buffer.html">TransformBuffer</a> {</div>
<div class="line">    glm::mat4 <a class="code" href="struct_transform_buffer.html#ae5b0677f80356d81a3ecafdefde105fa">World</a>;</div>
<div class="line">} transform;</div>
<div class="ttc" id="astruct_transform_buffer_html_ae5b0677f80356d81a3ecafdefde105fa"><div class="ttname"><a href="struct_transform_buffer.html#ae5b0677f80356d81a3ecafdefde105fa">TransformBuffer::World</a></div><div class="ttdeci">glm::mat4 World</div><div class="ttdef"><b>Definition:</b> sample.cpp:30</div></div>
</div><!-- fragment --><p>Next, we create three <code>Dynamic</code> buffers and map them to the descriptor set at space <em>1</em> that holds the per-frame transform buffer descriptors. There are three buffers, since we have three <em>frames in flight</em>, i.e. three frames that are computed concurrently. This equals the number of back-buffers in the swap chain, we created earlier. Since we have three buffers, we also need three descriptor sets, each containing a descriptor that points to the buffer for the current frame. The three buffers are stored in one <em>buffer array</em> with three elements, so each descriptor points to an individual element in the transform buffer array.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span>&amp; transformBindingLayout = m_pipeline-&gt;layout().layout(1);</div>
<div class="line">m_perFrameBindings = transformBindingLayout.allocate(3);</div>
<div class="line">m_transformBuffer = m_device-&gt;factory().createConstantBuffer(transformBindingLayout.layout(0), BufferUsage::Dynamic, 3);</div>
<div class="line">std::ranges::for_each(m_perFrameBindings, [<span class="keyword">this</span>, i = 0](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; descriptorSet) <span class="keyword">mutable</span> { descriptorSet-&gt;update(*m_transformBuffer, i++); });</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md37"></a>
Drawing Frames</h2>
<p>With everything setup so far, we can now start the actual drawing. Navigate to the main application loop (look for the <code>// TODO: draw frame.</code> comment) and start by swapping out the current back buffer:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> backBuffer = m_device-&gt;swapChain().swapBackBuffer();</div>
</div><!-- fragment --><p>The back buffer describes the resources that are used for the frame that is currently computed. This is done concurrently, so while a frame is still waiting to be drawn, future frames can already be recorded by the CPU. This ensures, the GPU is always busy with rendering.</p>
<p>Each frame is drawn in one or multiple sequential <em>render passes</em>. We already a single defined the render pass earlier, so all we need to do is tell the GPU to start on the current back buffer:</p>
<div class="fragment"><div class="line">m_renderPass-&gt;begin(backBuffer);</div>
</div><!-- fragment --><p>Next up, we want to handle drawing geometry. Each geometry draw call requires a certain <em>state</em> to let the GPU know, how to handle the data we pass to it. This state is contained the <em>pipeline</em> we defined earlier. In a real-world application, there may be many pipelines with different shaders, rasterizer and input assembler states. You should, however, always aim minimize the amount of pipeline switches. You can do this by pre-ordering the objects in your scene, so that you draw all objects that require the same pipeline state at the same time. In this example, however, we only have one pipeline state and we now tell the GPU to use it for the subsequent workload:</p>
<div class="fragment"><div class="line">m_pipeline-&gt;use();</div>
</div><!-- fragment --><p>Now it's time to update the transform buffer for our object. We want to animate a rotating triangle, so we can use a clock to dictate the amount of rotation. We use the duration since the beginning to compute a rotation matrix, that we use to update the transform buffer:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::now();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> now = std::chrono::high_resolution_clock::now();</div>
<div class="line"><span class="keyword">auto</span> time = std::chrono::duration&lt;float, std::chrono::seconds::period&gt;(now - start).count();</div>
<div class="line"> </div>
<div class="line">transform.<a class="code" href="struct_transform_buffer.html#ae5b0677f80356d81a3ecafdefde105fa">World</a> = glm::rotate(glm::mat4(1.0f), time * glm::radians(42.0f), glm::vec3(0.0f, 0.0f, 1.0f));</div>
<div class="line">m_transformBuffer-&gt;map(<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(&amp;transform), <span class="keyword">sizeof</span>(transform), backBuffer);</div>
</div><!-- fragment --><p>Before we can record the draw call, we need to make sure, the shader sees the right resources by binding all descriptor sets:</p>
<div class="fragment"><div class="line">m_pipeline-&gt;bind(*m_vertexBuffer);</div>
<div class="line">m_pipeline-&gt;bind(*m_indexBuffer);</div>
<div class="line">m_pipeline-&gt;bind(*m_cameraBindings);</div>
<div class="line">m_pipeline-&gt;bind(*m_perFrameBindings[backBuffer]);</div>
</div><!-- fragment --><p>Finally, we can record the actual draw call and end the render pass:</p>
<div class="fragment"><div class="line">m_pipeline-&gt;drawIndexed(m_indexBuffer-&gt;elements());</div>
<div class="line">m_renderPass-&gt;end();</div>
</div><!-- fragment --><p>When you launch the app now, you should see a rotating triangle in all its beauty.</p>
<h2><a class="anchor" id="autotoc_md38"></a>
Cleanup</h2>
<p>Before we can close our application, we need to ensure that all resources are properly released. Whilst not absolutely mandatory in release builds, this will satisfy the validation or debug layer (depending on your back-end):</p>
<div class="fragment"><div class="line"><span class="comment">// Shut down the device.</span></div>
<div class="line">m_device-&gt;wait();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Destroy all resources.</span></div>
<div class="line">m_cameraBindings = <span class="keyword">nullptr</span>;</div>
<div class="line">m_perFrameBindings.clear();</div>
<div class="line">m_cameraBuffer = <span class="keyword">nullptr</span>;</div>
<div class="line">m_cameraStagingBuffer = <span class="keyword">nullptr</span>;</div>
<div class="line">m_transformBuffer = <span class="keyword">nullptr</span>;</div>
<div class="line">m_vertexBuffer = <span class="keyword">nullptr</span>;</div>
<div class="line">m_indexBuffer = <span class="keyword">nullptr</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Destroy the pipeline, render pass and the device.</span></div>
<div class="line">m_pipeline = <span class="keyword">nullptr</span>;</div>
<div class="line">m_renderPass = <span class="keyword">nullptr</span>;</div>
<div class="line">m_device = <span class="keyword">nullptr</span>;</div>
</div><!-- fragment --><p>First we wait for the device to finish drawing the remaining frames. This ensures, that we do not destroy resources, that are still accessed by the GPU in any submitted command buffers. We then first destroy all descriptors and buffers, before finally releasing the pipeline, render pass and device instances.</p>
<h2><a class="anchor" id="autotoc_md39"></a>
Handling Resize-Events</h2>
<p>If you resize the window, you might notice that the backend will return an error. This is caused by the swap chain rendering to an outdated back-buffer. In order to support window resize events, let's implement the <code>SimpleApp::resize</code> method:</p>
<div class="fragment"><div class="line">App::resize(width, height);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (m_device == <span class="keyword">nullptr</span>)</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
</div><!-- fragment --><p>Since this method is inherited from the <code>App</code> base class, we first invoke the base class method. We then check, if the device has already been initialize, since resize-events may occur before any initialization has been done. If it is not initialized, there's no need for us to do anything else here. However, this during rendering it will be initialized, so let's continue with the implementation:</p>
<div class="fragment"><div class="line">m_device-&gt;wait();</div>
<div class="line"><span class="keyword">auto</span> surfaceFormat = m_device-&gt;swapChain().surfaceFormat();</div>
<div class="line"><span class="keyword">auto</span> renderArea = Size2d(width, height);</div>
</div><!-- fragment --><p>Again, we first wait for the device to finish all submitted work. This ensures that we do not destroy any back buffers, that might be still used by command buffers that are yet to be executed. Next we request the surface format from the current swap chain and initialize the new render area extent. We then can go ahead and re-create the swap chain, which causes the back buffers to be re-allocated with the new size and format. Furthermore, we can resize the frame buffers of our render pass. Note that you have to decide whether or not you want to do this, because you might have a render pass, that renders into a target that is deliberately at a different size than the swap chain back buffer. However, you almost certainly want to at least resize the frame buffer of the render pass that writes your present target.</p>
<div class="fragment"><div class="line">m_device-&gt;swapChain().reset(surfaceFormat, renderArea, 3);</div>
<div class="line">m_renderPass-&gt;resizeFrameBuffers(renderArea);</div>
</div><!-- fragment --><p>We then also resize the viewport and scissor rectangles, so that the image is drawn over the whole area of our resized window:</p>
<div class="fragment"><div class="line">m_viewport-&gt;setRectangle(RectF(0.f, 0.f, <span class="keyword">static_cast&lt;</span><a class="code" href="namespace_lite_f_x_1_1_math.html#a5f0e08243809f53dff6b21d29e8a6f75">Float</a><span class="keyword">&gt;</span>(width), <span class="keyword">static_cast&lt;</span><a class="code" href="namespace_lite_f_x_1_1_math.html#a5f0e08243809f53dff6b21d29e8a6f75">Float</a><span class="keyword">&gt;</span>(height)));</div>
<div class="line">m_scissor-&gt;setRectangle(RectF(0.f, 0.f, <span class="keyword">static_cast&lt;</span><a class="code" href="namespace_lite_f_x_1_1_math.html#a5f0e08243809f53dff6b21d29e8a6f75">Float</a><span class="keyword">&gt;</span>(width), <span class="keyword">static_cast&lt;</span><a class="code" href="namespace_lite_f_x_1_1_math.html#a5f0e08243809f53dff6b21d29e8a6f75">Float</a><span class="keyword">&gt;</span>(height)));</div>
</div><!-- fragment --><p>If you launch the application now and resize the window, it already should work. You might, however, notice that the image appears stretched. This is caused, because we also need to adjust the aspect ratio in our view/projection matrix. To do this, we can use the code we've written earlier to compute the camera buffer and update the buffer once again:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> aspectRatio = m_viewport-&gt;getRectangle().width() / m_viewport-&gt;getRectangle().height();</div>
<div class="line">glm::mat4 view = glm::lookAt(glm::vec3(1.5f, 1.5f, 1.5f), glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(0.0f, 0.0f, 1.0f));</div>
<div class="line">glm::mat4 projection = glm::perspective(glm::radians(60.0f), aspectRatio, 0.0001f, 1000.0f);</div>
<div class="line">projection[1][1] *= -1.f;   <span class="comment">// Fix GLM clip coordinate scaling.</span></div>
<div class="line">camera.<a class="code" href="struct_camera_buffer.html#a1b25393a92e2ce03ec2b51f5b5b18cdf">ViewProjection</a> = projection * view;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> commandBuffer = m_device-&gt;bufferQueue().createCommandBuffer(<span class="keyword">true</span>);</div>
<div class="line">m_cameraStagingBuffer-&gt;map(<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(&amp;camera), <span class="keyword">sizeof</span>(camera));</div>
<div class="line">m_cameraBuffer-&gt;transferFrom(*commandBuffer, *m_cameraStagingBuffer);</div>
<div class="line">commandBuffer-&gt;end(<span class="keyword">true</span>, <span class="keyword">true</span>);</div>
</div><!-- fragment --><p>Note that we do not have to release the command buffer explicitly here, since it will go out of scope anyway and will be released automatically.</p>
<h1><a class="anchor" id="autotoc_md40"></a>
Final Thoughts</h1>
<p>This quick start covered the basics on how to interact with the engine to write a modern graphics application. For more in-depth information about the inner workings of the engine, head over to the <a href="https://github.com/crud89/LiteFX/wiki">project wiki</a>. If you have any problems or want to contribute to the development, feel free to open an <a href="https://github.com/crud89/LiteFX/issues">issue</a> or create a <a href="https://github.com/crud89/LiteFX/pulls">pull request</a>.</p>
<p>Nevertheless, I hope you enjoy with the project. Happy coding! 👩‍💻👨‍💻 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
