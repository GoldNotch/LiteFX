<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LiteFX: LiteFX::Rendering::ICommandQueue&lt; TCommandBuffer, TBuffer, TVertexBuffer, TIndexBuffer, TImage, TBarrier, TPipeline &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo_xs.png"/></td>
  <td id="projectalign">
   <div id="projectname">LiteFX<span id="projectnumber">&#160;0.2.2.2022</span>
   </div>
   <div id="projectbrief">Computer Graphics Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_lite_f_x_1_1_rendering_1_1_i_command_queue.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_lite_f_x_1_1_rendering_1_1_i_command_queue-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">LiteFX::Rendering::ICommandQueue&lt; TCommandBuffer, TBuffer, TVertexBuffer, TIndexBuffer, TImage, TBarrier, TPipeline &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Represents a command queue.  
 <a href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="rendering_8hpp_source.html">rendering.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aaa5aedea7a89994c7c4db7025406d66e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html#aaa5aedea7a89994c7c4db7025406d66e">command_buffer_type</a> = TCommandBuffer</td></tr>
<tr class="separator:aaa5aedea7a89994c7c4db7025406d66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5a8156e016a24f6c5505a7a43e4f8b3a"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html#a5a8156e016a24f6c5505a7a43e4f8b3a">~ICommandQueue</a> () noexcept=default</td></tr>
<tr class="separator:a5a8156e016a24f6c5505a7a43e4f8b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5394da7aa1543bca98f04a94a22fae"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html#a5a5394da7aa1543bca98f04a94a22fae">isBound</a> () const noexcept=0</td></tr>
<tr class="memdesc:a5a5394da7aa1543bca98f04a94a22fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code>, if the command queue is bound on the parent device.  <a href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html#a5a5394da7aa1543bca98f04a94a22fae">More...</a><br /></td></tr>
<tr class="separator:a5a5394da7aa1543bca98f04a94a22fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb7f34585f26689e078074bdb2487b7a"><td class="memItemLeft" align="right" valign="top">virtual const QueuePriority &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html#abb7f34585f26689e078074bdb2487b7a">priority</a> () const noexcept=0</td></tr>
<tr class="memdesc:abb7f34585f26689e078074bdb2487b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the priority of the queue.  <a href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html#abb7f34585f26689e078074bdb2487b7a">More...</a><br /></td></tr>
<tr class="separator:abb7f34585f26689e078074bdb2487b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7ff565dd9164549929d3e07e85cfdd"><td class="memItemLeft" align="right" valign="top">virtual const QueueType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html#a1f7ff565dd9164549929d3e07e85cfdd">type</a> () const noexcept=0</td></tr>
<tr class="memdesc:a1f7ff565dd9164549929d3e07e85cfdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of the queue.  <a href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html#a1f7ff565dd9164549929d3e07e85cfdd">More...</a><br /></td></tr>
<tr class="separator:a1f7ff565dd9164549929d3e07e85cfdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8e45ebf000946858082349abbb8c6b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html#afc8e45ebf000946858082349abbb8c6b">bind</a> ()=0</td></tr>
<tr class="memdesc:afc8e45ebf000946858082349abbb8c6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds the queue on the parent device.  <a href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html#afc8e45ebf000946858082349abbb8c6b">More...</a><br /></td></tr>
<tr class="separator:afc8e45ebf000946858082349abbb8c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5acb1af675457537d69a9c8d08c81e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html#a6b5acb1af675457537d69a9c8d08c81e">release</a> ()=0</td></tr>
<tr class="memdesc:a6b5acb1af675457537d69a9c8d08c81e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the queue from the parent device.  <a href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html#a6b5acb1af675457537d69a9c8d08c81e">More...</a><br /></td></tr>
<tr class="separator:a6b5acb1af675457537d69a9c8d08c81e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9c3ebe5c551c04cb0891c359be7d70"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_lite_f_x.html#abc27711f32315287f061ac8b253f3ca4">UniquePtr</a>&lt; TCommandBuffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html#afa9c3ebe5c551c04cb0891c359be7d70">createCommandBuffer</a> (const bool &amp;beginRecording=false) const =0</td></tr>
<tr class="memdesc:afa9c3ebe5c551c04cb0891c359be7d70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a command buffer that can be used to allocate commands on the queue.  <a href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html#afa9c3ebe5c551c04cb0891c359be7d70">More...</a><br /></td></tr>
<tr class="separator:afa9c3ebe5c551c04cb0891c359be7d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398903b1e09a24cc7dc6af79b2f75a97"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_lite_f_x_1_1_math.html#a61c5cb713e801152ad8098c7b7d0f427">UInt64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html#a398903b1e09a24cc7dc6af79b2f75a97">submit</a> (const TCommandBuffer &amp;commandBuffer) const =0</td></tr>
<tr class="memdesc:a398903b1e09a24cc7dc6af79b2f75a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a single command buffer and inserts a fence to wait for it.  <a href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html#a398903b1e09a24cc7dc6af79b2f75a97">More...</a><br /></td></tr>
<tr class="separator:a398903b1e09a24cc7dc6af79b2f75a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c843f4b558ac3a401e1ab73e7a4be61"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_lite_f_x_1_1_math.html#a61c5cb713e801152ad8098c7b7d0f427">UInt64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html#a2c843f4b558ac3a401e1ab73e7a4be61">submit</a> (const <a class="el" href="namespace_lite_f_x.html#a44a0ba2aca32b92906c89ef4df069dbe">Array</a>&lt; const TCommandBuffer * &gt; &amp;commandBuffers) const =0</td></tr>
<tr class="memdesc:a2c843f4b558ac3a401e1ab73e7a4be61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a set of command buffers and inserts a fence to wait for them.  <a href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html#a2c843f4b558ac3a401e1ab73e7a4be61">More...</a><br /></td></tr>
<tr class="separator:a2c843f4b558ac3a401e1ab73e7a4be61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff1a27a568ec9ad4cab1fc6d08b22610"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html#aff1a27a568ec9ad4cab1fc6d08b22610">waitFor</a> (const <a class="el" href="namespace_lite_f_x_1_1_math.html#a61c5cb713e801152ad8098c7b7d0f427">UInt64</a> &amp;fence) const noexcept=0</td></tr>
<tr class="memdesc:aff1a27a568ec9ad4cab1fc6d08b22610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for a certain fence value to complete on the command queue.  <a href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html#aff1a27a568ec9ad4cab1fc6d08b22610">More...</a><br /></td></tr>
<tr class="separator:aff1a27a568ec9ad4cab1fc6d08b22610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34c25a906f202b1e86c65e4df447d7f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_lite_f_x_1_1_math.html#a61c5cb713e801152ad8098c7b7d0f427">UInt64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html#ae34c25a906f202b1e86c65e4df447d7f">currentFence</a> () const noexcept=0</td></tr>
<tr class="memdesc:ae34c25a906f202b1e86c65e4df447d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the latest fence inserted into the queue.  <a href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html#ae34c25a906f202b1e86c65e4df447d7f">More...</a><br /></td></tr>
<tr class="separator:ae34c25a906f202b1e86c65e4df447d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename TCommandBuffer, typename TBuffer = TCommandBuffer::buffer_type, typename TVertexBuffer = TCommandBuffer::vertex_buffer_type, typename TIndexBuffer = TCommandBuffer::index_buffer_type, typename TImage = TCommandBuffer::image_type, typename TBarrier = TCommandBuffer::barrier_type, typename TPipeline = TCommandBuffer::pipeline_type&gt;<br />
requires rtti::implements&lt;TCommandBuffer, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html">ICommandBuffer</a>&lt;TBuffer, TVertexBuffer, TIndexBuffer, TImage, TBarrier, TPipeline&gt;&gt;<br />
class LiteFX::Rendering::ICommandQueue&lt; TCommandBuffer, TBuffer, TVertexBuffer, TIndexBuffer, TImage, TBarrier, TPipeline &gt;</div><p >Represents a command queue. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCommandBuffer</td><td>The type of the command buffer for this queue. Must implement <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html" title="Represents a command buffer, that buffers commands that should be submitted to a ICommandQueue.">ICommandBuffer</a>.</td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aaa5aedea7a89994c7c4db7025406d66e" name="aaa5aedea7a89994c7c4db7025406d66e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa5aedea7a89994c7c4db7025406d66e">&#9670;&nbsp;</a></span>command_buffer_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TCommandBuffer , typename TBuffer  = TCommandBuffer::buffer_type, typename TVertexBuffer  = TCommandBuffer::vertex_buffer_type, typename TIndexBuffer  = TCommandBuffer::index_buffer_type, typename TImage  = TCommandBuffer::image_type, typename TBarrier  = TCommandBuffer::barrier_type, typename TPipeline  = TCommandBuffer::pipeline_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html">LiteFX::Rendering::ICommandQueue</a>&lt; TCommandBuffer, TBuffer, TVertexBuffer, TIndexBuffer, TImage, TBarrier, TPipeline &gt;::command_buffer_type =  TCommandBuffer</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5a8156e016a24f6c5505a7a43e4f8b3a" name="a5a8156e016a24f6c5505a7a43e4f8b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a8156e016a24f6c5505a7a43e4f8b3a">&#9670;&nbsp;</a></span>~ICommandQueue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TCommandBuffer , typename TBuffer  = TCommandBuffer::buffer_type, typename TVertexBuffer  = TCommandBuffer::vertex_buffer_type, typename TIndexBuffer  = TCommandBuffer::index_buffer_type, typename TImage  = TCommandBuffer::image_type, typename TBarrier  = TCommandBuffer::barrier_type, typename TPipeline  = TCommandBuffer::pipeline_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html">LiteFX::Rendering::ICommandQueue</a>&lt; TCommandBuffer, TBuffer, TVertexBuffer, TIndexBuffer, TImage, TBarrier, TPipeline &gt;::~<a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html">ICommandQueue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afc8e45ebf000946858082349abbb8c6b" name="afc8e45ebf000946858082349abbb8c6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc8e45ebf000946858082349abbb8c6b">&#9670;&nbsp;</a></span>bind()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TCommandBuffer , typename TBuffer  = TCommandBuffer::buffer_type, typename TVertexBuffer  = TCommandBuffer::vertex_buffer_type, typename TIndexBuffer  = TCommandBuffer::index_buffer_type, typename TImage  = TCommandBuffer::image_type, typename TBarrier  = TCommandBuffer::barrier_type, typename TPipeline  = TCommandBuffer::pipeline_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html">LiteFX::Rendering::ICommandQueue</a>&lt; TCommandBuffer, TBuffer, TVertexBuffer, TIndexBuffer, TImage, TBarrier, TPipeline &gt;::bind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binds the queue on the parent device. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html#a5a5394da7aa1543bca98f04a94a22fae" title="Returns true, if the command queue is bound on the parent device.">isBound</a></dd></dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_queue.html#a67a410ed3ebe8f4ebaa1e6d0b2439340">LiteFX::Rendering::Backends::DirectX12Queue</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_queue.html#a54263aad570bf5de59a2bd9ffaa1283c">LiteFX::Rendering::Backends::VulkanQueue</a>.</p>

</div>
</div>
<a id="afa9c3ebe5c551c04cb0891c359be7d70" name="afa9c3ebe5c551c04cb0891c359be7d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa9c3ebe5c551c04cb0891c359be7d70">&#9670;&nbsp;</a></span>createCommandBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TCommandBuffer , typename TBuffer  = TCommandBuffer::buffer_type, typename TVertexBuffer  = TCommandBuffer::vertex_buffer_type, typename TIndexBuffer  = TCommandBuffer::index_buffer_type, typename TImage  = TCommandBuffer::image_type, typename TBarrier  = TCommandBuffer::barrier_type, typename TPipeline  = TCommandBuffer::pipeline_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_lite_f_x.html#abc27711f32315287f061ac8b253f3ca4">UniquePtr</a>&lt; TCommandBuffer &gt; <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html">LiteFX::Rendering::ICommandQueue</a>&lt; TCommandBuffer, TBuffer, TVertexBuffer, TIndexBuffer, TImage, TBarrier, TPipeline &gt;::createCommandBuffer </td>
          <td>(</td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>beginRecording</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a command buffer that can be used to allocate commands on the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beginRecording</td><td>If set to <code>true</code>, the command buffer will be initialized in recording state and can receive commands straight away.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The instance of the command buffer.</dd></dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_queue.html#a40563e8d1021c5697e6dc679d19997f5">LiteFX::Rendering::Backends::DirectX12Queue</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_queue.html#a910333138e1b2bc7183e14a793b2ae28">LiteFX::Rendering::Backends::VulkanQueue</a>.</p>

</div>
</div>
<a id="ae34c25a906f202b1e86c65e4df447d7f" name="ae34c25a906f202b1e86c65e4df447d7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34c25a906f202b1e86c65e4df447d7f">&#9670;&nbsp;</a></span>currentFence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TCommandBuffer , typename TBuffer  = TCommandBuffer::buffer_type, typename TVertexBuffer  = TCommandBuffer::vertex_buffer_type, typename TIndexBuffer  = TCommandBuffer::index_buffer_type, typename TImage  = TCommandBuffer::image_type, typename TBarrier  = TCommandBuffer::barrier_type, typename TPipeline  = TCommandBuffer::pipeline_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_lite_f_x_1_1_math.html#a61c5cb713e801152ad8098c7b7d0f427">UInt64</a> <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html">LiteFX::Rendering::ICommandQueue</a>&lt; TCommandBuffer, TBuffer, TVertexBuffer, TIndexBuffer, TImage, TBarrier, TPipeline &gt;::currentFence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of the latest fence inserted into the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>The value of the latest fence inserted into the queue.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html#aff1a27a568ec9ad4cab1fc6d08b22610" title="Waits for a certain fence value to complete on the command queue.">waitFor</a></dd></dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_queue.html#ad7fe907c0a3987dcec37e099684588e8">LiteFX::Rendering::Backends::DirectX12Queue</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_queue.html#ad308995a0783ad3639e84505fb5304ba">LiteFX::Rendering::Backends::VulkanQueue</a>.</p>

</div>
</div>
<a id="a5a5394da7aa1543bca98f04a94a22fae" name="a5a5394da7aa1543bca98f04a94a22fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a5394da7aa1543bca98f04a94a22fae">&#9670;&nbsp;</a></span>isBound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TCommandBuffer , typename TBuffer  = TCommandBuffer::buffer_type, typename TVertexBuffer  = TCommandBuffer::vertex_buffer_type, typename TIndexBuffer  = TCommandBuffer::index_buffer_type, typename TImage  = TCommandBuffer::image_type, typename TBarrier  = TCommandBuffer::barrier_type, typename TPipeline  = TCommandBuffer::pipeline_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html">LiteFX::Rendering::ICommandQueue</a>&lt; TCommandBuffer, TBuffer, TVertexBuffer, TIndexBuffer, TImage, TBarrier, TPipeline &gt;::isBound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code>, if the command queue is bound on the parent device. </p>
<p >Before a command queue can receive commands, it needs to be bound to a device. This ensures, that the queue is actually able to allocate commands. A command queue starts in unbound state until <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html#afc8e45ebf000946858082349abbb8c6b" title="Binds the queue on the parent device.">bind</a> gets called. Destroying the queue also releases it by calling <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html#a6b5acb1af675457537d69a9c8d08c81e" title="Releases the queue from the parent device.">release</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html#afc8e45ebf000946858082349abbb8c6b" title="Binds the queue on the parent device.">bind</a>, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html#a6b5acb1af675457537d69a9c8d08c81e" title="Releases the queue from the parent device.">release</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code>, if the command queue is bound on a device.</dd></dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_queue.html#a3af18988b8ca3fe0b2ec4d5746e33f17">LiteFX::Rendering::Backends::DirectX12Queue</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_queue.html#ad17264b41ef5672143fe673c63000b93">LiteFX::Rendering::Backends::VulkanQueue</a>.</p>

</div>
</div>
<a id="abb7f34585f26689e078074bdb2487b7a" name="abb7f34585f26689e078074bdb2487b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb7f34585f26689e078074bdb2487b7a">&#9670;&nbsp;</a></span>priority()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TCommandBuffer , typename TBuffer  = TCommandBuffer::buffer_type, typename TVertexBuffer  = TCommandBuffer::vertex_buffer_type, typename TIndexBuffer  = TCommandBuffer::index_buffer_type, typename TImage  = TCommandBuffer::image_type, typename TBarrier  = TCommandBuffer::barrier_type, typename TPipeline  = TCommandBuffer::pipeline_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const QueuePriority &amp; <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html">LiteFX::Rendering::ICommandQueue</a>&lt; TCommandBuffer, TBuffer, TVertexBuffer, TIndexBuffer, TImage, TBarrier, TPipeline &gt;::priority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the priority of the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>The priority of the queue.</dd></dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_queue.html#a41ff6f892558404295997dceac1218b1">LiteFX::Rendering::Backends::DirectX12Queue</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_queue.html#a94344091ff9f60576f6d7eef059f1f3a">LiteFX::Rendering::Backends::VulkanQueue</a>.</p>

</div>
</div>
<a id="a6b5acb1af675457537d69a9c8d08c81e" name="a6b5acb1af675457537d69a9c8d08c81e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b5acb1af675457537d69a9c8d08c81e">&#9670;&nbsp;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TCommandBuffer , typename TBuffer  = TCommandBuffer::buffer_type, typename TVertexBuffer  = TCommandBuffer::vertex_buffer_type, typename TIndexBuffer  = TCommandBuffer::index_buffer_type, typename TImage  = TCommandBuffer::image_type, typename TBarrier  = TCommandBuffer::barrier_type, typename TPipeline  = TCommandBuffer::pipeline_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html">LiteFX::Rendering::ICommandQueue</a>&lt; TCommandBuffer, TBuffer, TVertexBuffer, TIndexBuffer, TImage, TBarrier, TPipeline &gt;::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases the queue from the parent device. </p>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_queue.html#a84c29c4f51741f5b46582cfdb4ac090a">LiteFX::Rendering::Backends::DirectX12Queue</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_queue.html#a7b79ca8ea1e82cc71f19ac96e4194532">LiteFX::Rendering::Backends::VulkanQueue</a>.</p>

</div>
</div>
<a id="a2c843f4b558ac3a401e1ab73e7a4be61" name="a2c843f4b558ac3a401e1ab73e7a4be61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c843f4b558ac3a401e1ab73e7a4be61">&#9670;&nbsp;</a></span>submit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TCommandBuffer , typename TBuffer  = TCommandBuffer::buffer_type, typename TVertexBuffer  = TCommandBuffer::vertex_buffer_type, typename TIndexBuffer  = TCommandBuffer::index_buffer_type, typename TImage  = TCommandBuffer::image_type, typename TBarrier  = TCommandBuffer::barrier_type, typename TPipeline  = TCommandBuffer::pipeline_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_lite_f_x_1_1_math.html#a61c5cb713e801152ad8098c7b7d0f427">UInt64</a> <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html">LiteFX::Rendering::ICommandQueue</a>&lt; TCommandBuffer, TBuffer, TVertexBuffer, TIndexBuffer, TImage, TBarrier, TPipeline &gt;::submit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x.html#a44a0ba2aca32b92906c89ef4df069dbe">Array</a>&lt; const TCommandBuffer * &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffers</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submits a set of command buffers and inserts a fence to wait for them. </p>
<p >Note that submitting a command buffer that is currently recording will implicitly close the command buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandBuffers</td><td>The command buffers to submit to the command queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the fence, inserted after the command buffers.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html#aff1a27a568ec9ad4cab1fc6d08b22610" title="Waits for a certain fence value to complete on the command queue.">waitFor</a></dd></dl>

</div>
</div>
<a id="a398903b1e09a24cc7dc6af79b2f75a97" name="a398903b1e09a24cc7dc6af79b2f75a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a398903b1e09a24cc7dc6af79b2f75a97">&#9670;&nbsp;</a></span>submit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TCommandBuffer , typename TBuffer  = TCommandBuffer::buffer_type, typename TVertexBuffer  = TCommandBuffer::vertex_buffer_type, typename TIndexBuffer  = TCommandBuffer::index_buffer_type, typename TImage  = TCommandBuffer::image_type, typename TBarrier  = TCommandBuffer::barrier_type, typename TPipeline  = TCommandBuffer::pipeline_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_lite_f_x_1_1_math.html#a61c5cb713e801152ad8098c7b7d0f427">UInt64</a> <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html">LiteFX::Rendering::ICommandQueue</a>&lt; TCommandBuffer, TBuffer, TVertexBuffer, TIndexBuffer, TImage, TBarrier, TPipeline &gt;::submit </td>
          <td>(</td>
          <td class="paramtype">const TCommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submits a single command buffer and inserts a fence to wait for it. </p>
<p >Note that submitting a command buffer that is currently recording will implicitly close the command buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandBuffer</td><td>The command buffer to submit to the command queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the fence, inserted after the command buffer.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html#aff1a27a568ec9ad4cab1fc6d08b22610" title="Waits for a certain fence value to complete on the command queue.">waitFor</a></dd></dl>

</div>
</div>
<a id="a1f7ff565dd9164549929d3e07e85cfdd" name="a1f7ff565dd9164549929d3e07e85cfdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f7ff565dd9164549929d3e07e85cfdd">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TCommandBuffer , typename TBuffer  = TCommandBuffer::buffer_type, typename TVertexBuffer  = TCommandBuffer::vertex_buffer_type, typename TIndexBuffer  = TCommandBuffer::index_buffer_type, typename TImage  = TCommandBuffer::image_type, typename TBarrier  = TCommandBuffer::barrier_type, typename TPipeline  = TCommandBuffer::pipeline_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const QueueType &amp; <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html">LiteFX::Rendering::ICommandQueue</a>&lt; TCommandBuffer, TBuffer, TVertexBuffer, TIndexBuffer, TImage, TBarrier, TPipeline &gt;::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the type of the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>The type of the queue.</dd></dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_queue.html#a5f91421f0a00f5196c3f0333cbc9a23e">LiteFX::Rendering::Backends::DirectX12Queue</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_queue.html#ae9f1a34a2329c47456b5a593983b6c4e">LiteFX::Rendering::Backends::VulkanQueue</a>.</p>

</div>
</div>
<a id="aff1a27a568ec9ad4cab1fc6d08b22610" name="aff1a27a568ec9ad4cab1fc6d08b22610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff1a27a568ec9ad4cab1fc6d08b22610">&#9670;&nbsp;</a></span>waitFor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TCommandBuffer , typename TBuffer  = TCommandBuffer::buffer_type, typename TVertexBuffer  = TCommandBuffer::vertex_buffer_type, typename TIndexBuffer  = TCommandBuffer::index_buffer_type, typename TImage  = TCommandBuffer::image_type, typename TBarrier  = TCommandBuffer::barrier_type, typename TPipeline  = TCommandBuffer::pipeline_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html">LiteFX::Rendering::ICommandQueue</a>&lt; TCommandBuffer, TBuffer, TVertexBuffer, TIndexBuffer, TImage, TBarrier, TPipeline &gt;::waitFor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x_1_1_math.html#a61c5cb713e801152ad8098c7b7d0f427">UInt64</a> &amp;&#160;</td>
          <td class="paramname"><em>fence</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits for a certain fence value to complete on the command queue. </p>
<p >Each time one or more command buffers are submitted to the queue, a fence is inserted and its value will be returned. By calling this method, it is possible to wait for this fence. A fence value is guaranteed to be larger than earlier fences, so the method returns, if the latest signaled fence value is larger or equal to the value specified in <em>fence</em> .</p>
<p >Note that this behavior can cause overflows when performing <em>excessive</em> fencing! Take for example a scenario, where each frame requires 80 fences to be signaled and an application that runs at 60 frames per second in average. In this case, each second 4.800 fences are inserted into the queue. Given the limit of an 64 bit unsigned integer fence value, the application can run ~2.9 billion years before overflowing. Drop me an e-mail or open an issue, if you ever happen to run into such a situation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fence</td><td>The value of the fence to wait for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html#a398903b1e09a24cc7dc6af79b2f75a97" title="Submits a single command buffer and inserts a fence to wait for it.">submit</a></dd></dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_queue.html#ac9b75efd1acd6f96f954c9d9761ef56d">LiteFX::Rendering::Backends::DirectX12Queue</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_queue.html#ae6382b9f2ed01615b303d6829d9772e7">LiteFX::Rendering::Backends::VulkanQueue</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_lite_f_x.html">LiteFX</a></li><li class="navelem"><a class="el" href="namespace_lite_f_x_1_1_rendering.html">Rendering</a></li><li class="navelem"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html">ICommandQueue</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
